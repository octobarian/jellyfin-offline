{% extends "base.html" %}

{% block title %}Media Library - RV Media Player{% endblock %}

{% block head %}
<style>
    .system-status {
        background-color: #2d2d2d;
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 2rem;
        display: flex;
        gap: 2rem;
        flex-wrap: wrap;
    }
    
    .status-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }
    
    /* Media Section Headers */
    .media-section {
        margin-bottom: 3rem;
    }
    
    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 2px solid #4CAF50;
    }
    
    .section-title {
        font-size: 1.8rem;
        font-weight: 600;
        color: #4CAF50;
        margin: 0;
    }
    
    .section-count {
        background-color: #4CAF50;
        color: white;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 0.9rem;
        font-weight: 500;
    }
    
    /* Enhanced Media Grid */
    .media-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 1.5rem;
        margin-top: 1rem;
    }
    
    /* Responsive grid adjustments */
    @media (max-width: 576px) {
        .media-grid {
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 1rem;
        }
    }
    
    @media (min-width: 768px) {
        .media-grid {
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        }
    }
    
    @media (min-width: 992px) {
        .media-grid {
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        }
    }
    
    /* Enhanced Media Card */
    .media-card {
        position: relative;
        background-color: transparent;
        border-radius: 12px;
        transition: all 0.3s ease;
        cursor: pointer;
        overflow: hidden;
    }
    
    .media-card:hover {
        transform: translateY(-4px) scale(1.02);
    }
    
    /* Movie Poster Container */
    .media-poster {
        position: relative;
        width: 100%;
        aspect-ratio: 2/3; /* Standard movie poster ratio */
        background-color: #1a1a1a;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        transition: all 0.3s ease;
    }
    
    .media-card:hover .media-poster {
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
    }
    
    .media-poster img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        transition: opacity 0.3s ease;
    }
    
    .media-poster .poster-placeholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%);
        color: #666;
        text-align: center;
        padding: 1rem;
    }
    
    .poster-placeholder .placeholder-icon {
        font-size: 3rem;
        margin-bottom: 0.5rem;
        opacity: 0.5;
    }
    
    .poster-placeholder .placeholder-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: #aaa;
        line-height: 1.3;
        word-wrap: break-word;
        hyphens: auto;
    }
    
    /* Loading State */
    .media-poster.loading {
        background: linear-gradient(90deg, #2d2d2d 25%, #3d3d3d 50%, #2d2d2d 75%);
        background-size: 200% 100%;
        animation: loading-shimmer 1.5s infinite;
    }
    
    @keyframes loading-shimmer {
        0% { background-position: 200% 0; }
        100% { background-position: -200% 0; }
    }
    
    /* Download Progress Overlay */
    .download-progress {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        z-index: 10;
    }
    
    .download-progress.active {
        opacity: 1;
        visibility: visible;
    }
    
    .progress-container {
        width: 80%;
        max-width: 200px;
        margin-bottom: 1rem;
    }
    
    .progress-bar {
        width: 100%;
        height: 8px;
        background-color: #333;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #66BB6A);
        border-radius: 4px;
        transition: width 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .progress-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        animation: progress-shine 2s infinite;
    }
    
    @keyframes progress-shine {
        0% { transform: translateX(-100%); }
        100% { transform: translateX(100%); }
    }
    
    .progress-text {
        color: white;
        font-size: 0.9rem;
        font-weight: 600;
        text-align: center;
        margin-bottom: 0.5rem;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    }
    
    .progress-details {
        color: #ccc;
        font-size: 0.8rem;
        text-align: center;
        line-height: 1.3;
    }
    
    .progress-cancel {
        margin-top: 1rem;
        padding: 6px 12px;
        background-color: #f44336;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8rem;
        transition: background-color 0.2s ease;
        min-height: 32px;
    }
    
    .progress-cancel:hover {
        background-color: #da190b;
    }
    
    /* System Status Display */
    .system-status {
        display: flex;
        gap: 2rem;
        margin-bottom: 2rem;
        padding: 1rem;
        background-color: #2d2d2d;
        border-radius: 8px;
        flex-wrap: wrap;
        transition: all 0.3s ease;
    }
    
    .system-status.offline {
        background-color: #3d2d1d;
        border: 2px solid #ff9800;
    }
    
    .system-status.degraded {
        background-color: #3d3d1d;
        border: 2px solid #ffc107;
    }
    
    .system-status .status-indicator {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 8px;
        transition: all 0.3s ease;
        position: relative;
    }
    
    .system-status .status-online {
        background-color: #4CAF50;
        box-shadow: 0 0 6px rgba(76, 175, 80, 0.6);
        animation: pulse-online 2s infinite;
    }
    
    .system-status .status-offline {
        background-color: #f44336;
        box-shadow: 0 0 6px rgba(244, 67, 54, 0.6);
        animation: pulse-offline 2s infinite;
    }
    
    .system-status .status-warning {
        background-color: #ff9800;
        box-shadow: 0 0 6px rgba(255, 152, 0, 0.6);
        animation: pulse-warning 2s infinite;
    }
    
    .system-status .status-checking {
        background-color: #2196F3;
        box-shadow: 0 0 6px rgba(33, 150, 243, 0.6);
        animation: pulse-checking 1s infinite;
        position: relative;
    }
    
    /* Enhanced checking animation with spinner effect */
    .system-status .status-checking::after {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        border: 2px solid transparent;
        border-top: 2px solid #2196F3;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }
    
    @keyframes pulse-online {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes pulse-offline {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    @keyframes pulse-warning {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    
    @keyframes pulse-checking {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.1); }
    }
    
    /* Download Queue Indicator */
    .download-queue {
        position: fixed;
        top: 80px;
        right: 20px;
        background-color: #2d2d2d;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 1001;
        max-width: 300px;
        opacity: 0;
        visibility: hidden;
        transform: translateX(100%);
        transition: all 0.3s ease;
    }
    
    .download-queue.active {
        opacity: 1;
        visibility: visible;
        transform: translateX(0);
    }
    
    .queue-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #444;
    }
    
    .queue-title {
        font-size: 1rem;
        font-weight: 600;
        color: #4CAF50;
    }
    
    .queue-close {
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 4px;
        transition: all 0.2s ease;
    }
    
    .queue-close:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: white;
    }
    
    .queue-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 0;
        border-bottom: 1px solid #333;
    }
    
    .queue-item:last-child {
        border-bottom: none;
    }
    
    .queue-poster {
        width: 40px;
        height: 60px;
        background-color: #1a1a1a;
        border-radius: 4px;
        overflow: hidden;
        flex-shrink: 0;
    }
    
    .queue-poster img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .queue-info {
        flex: 1;
        min-width: 0;
    }
    
    .queue-title-text {
        font-size: 0.9rem;
        font-weight: 500;
        color: white;
        margin-bottom: 0.25rem;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    
    .queue-progress {
        font-size: 0.8rem;
        color: #4CAF50;
        margin-bottom: 0.25rem;
    }
    
    .queue-status {
        font-size: 0.7rem;
        color: #aaa;
    }
    
    /* Media Info Overlay */
    .media-info {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
        color: white;
        padding: 2rem 1rem 1rem;
        transform: translateY(100%);
        transition: transform 0.3s ease;
    }
    
    .media-card:hover .media-info {
        transform: translateY(0);
    }
    
    /* Interactive Action Overlay */
    .action-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
    }
    
    .action-overlay.active {
        opacity: 1;
        visibility: visible;
    }
    
    .action-overlay-content {
        background-color: #2d2d2d;
        border-radius: 16px;
        padding: 2rem;
        max-width: 90vw;
        max-height: 90vh;
        overflow-y: auto;
        transform: scale(0.9);
        transition: transform 0.3s ease;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        position: relative;
    }
    
    .action-overlay.active .action-overlay-content {
        transform: scale(1);
    }
    
    .overlay-close {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.5rem;
        cursor: pointer;
        padding: 0.5rem;
        border-radius: 50%;
        transition: all 0.2s ease;
        min-height: 44px;
        min-width: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .overlay-close:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: white;
    }
    
    .overlay-media-info {
        display: flex;
        gap: 2rem;
        margin-bottom: 2rem;
    }
    
    .overlay-poster {
        flex-shrink: 0;
        width: 200px;
        aspect-ratio: 2/3;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }
    
    .overlay-poster img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    
    .overlay-details {
        flex: 1;
        min-width: 0;
    }
    
    .overlay-title {
        font-size: 2rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        color: #ffffff;
        line-height: 1.2;
    }
    
    .overlay-meta {
        font-size: 1rem;
        color: #aaa;
        margin-bottom: 1rem;
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
    }
    
    .overlay-description {
        font-size: 1rem;
        line-height: 1.6;
        color: #ccc;
        margin-bottom: 2rem;
    }
    
    .overlay-actions {
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
        margin-bottom: 2rem;
    }
    
    .overlay-actions .btn {
        min-width: 120px;
        padding: 12px 24px;
        font-size: 16px;
        min-height: 48px;
    }
    
    /* Overlay Action Button Styling */
    .overlay-action-btn {
        display: flex;
        align-items: center;
        justify-content: flex-start;
        gap: 12px;
        padding: 16px 24px;
        min-height: 56px;
        min-width: 160px;
        background: linear-gradient(135deg, #2d2d2d 0%, #3d3d3d 100%);
        color: white;
        border: 2px solid transparent;
        border-radius: 12px;
        cursor: pointer;
        font-size: 16px;
        font-weight: 500;
        transition: all 0.3s ease;
        text-decoration: none;
        position: relative;
        overflow: hidden;
    }
    
    .overlay-action-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        border-color: #4CAF50;
    }
    
    .overlay-action-btn:active {
        transform: translateY(0);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    /* Specific button type styling for overlay */
    .overlay-action-btn.btn-play-overlay {
        background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
        border-color: #FF9800;
    }
    
    .overlay-action-btn.btn-play-overlay:hover {
        background: linear-gradient(135deg, #F57C00 0%, #E65100 100%);
        border-color: #FF9800;
        box-shadow: 0 8px 24px rgba(255, 152, 0, 0.4);
    }
    
    .overlay-action-btn.btn-stream-overlay {
        background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        border-color: #2196F3;
    }
    
    .overlay-action-btn.btn-stream-overlay:hover {
        background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        border-color: #2196F3;
        box-shadow: 0 8px 24px rgba(33, 150, 243, 0.4);
    }
    
    .overlay-action-btn.btn-download-overlay {
        background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
        border-color: #4CAF50;
    }
    
    .overlay-action-btn.btn-download-overlay:hover {
        background: linear-gradient(135deg, #388E3C 0%, #2E7D32 100%);
        border-color: #4CAF50;
        box-shadow: 0 8px 24px rgba(76, 175, 80, 0.4);
    }
    
    .overlay-action-btn.disabled {
        background: linear-gradient(135deg, #555 0%, #444 100%);
        color: #aaa;
        cursor: not-allowed;
        border-color: #555;
    }
    
    .overlay-action-btn.disabled:hover {
        transform: none;
        box-shadow: none;
        border-color: #555;
    }
    
    .overlay-action-btn .btn-icon {
        font-size: 20px;
        flex-shrink: 0;
    }
    
    .overlay-action-btn .btn-text {
        font-weight: 600;
        flex: 1;
    }
    
    /* Shimmer effect for overlay buttons */
    .overlay-action-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
        transition: left 0.5s ease;
    }
    
    .overlay-action-btn:hover::before {
        left: 100%;
    }
    
    .overlay-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 1rem;
        margin-top: 2rem;
    }
    
    .stat-item {
        background-color: #1a1a1a;
        padding: 1rem;
        border-radius: 8px;
        text-align: center;
    }
    
    .stat-label {
        font-size: 0.9rem;
        color: #aaa;
        margin-bottom: 0.25rem;
    }
    
    .stat-value {
        font-size: 1.1rem;
        font-weight: 600;
        color: #4CAF50;
    }
    
    /* Responsive overlay adjustments */
    @media (max-width: 768px) {
        .action-overlay-content {
            padding: 1.5rem;
            margin: 1rem;
        }
        
        .overlay-media-info {
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .overlay-poster {
            width: 150px;
            align-self: center;
        }
        
        .overlay-title {
            font-size: 1.5rem;
        }
        
        .overlay-actions {
            flex-direction: column;
        }
        
        .overlay-actions .btn {
            width: 100%;
        }
    }
    
    .media-title {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.25rem;
        line-height: 1.2;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
    }
    
    .media-meta {
        font-size: 0.8rem;
        color: #ccc;
        margin-bottom: 0.75rem;
        opacity: 0.9;
    }
    
    .media-actions {
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .media-actions .btn {
        flex: 1;
        min-width: 60px;
        padding: 6px 12px;
        font-size: 12px;
        min-height: 32px;
        border-radius: 6px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 4px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    /* Stream Button Styling */
    .media-actions .btn-stream {
        background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
    }
    
    .media-actions .btn-stream:hover {
        background: linear-gradient(135deg, #1976D2 0%, #1565C0 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
    }
    
    .media-actions .btn-stream:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(33, 150, 243, 0.3);
    }
    
    /* Download Button Styling */
    .media-actions .btn-download {
        background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
    }
    
    .media-actions .btn-download:hover {
        background: linear-gradient(135deg, #388E3C 0%, #2E7D32 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
    }
    
    .media-actions .btn-download:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);
    }
    
    /* Play Button Styling */
    .media-actions .btn-play {
        background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
        color: white;
        box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
    }
    
    .media-actions .btn-play:hover {
        background: linear-gradient(135deg, #F57C00 0%, #E65100 100%);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
    }
    
    .media-actions .btn-play:active {
        transform: translateY(0);
        box-shadow: 0 2px 6px rgba(255, 152, 0, 0.3);
    }
    
    /* Button Icons */
    .media-actions .btn-icon {
        font-size: 14px;
        margin-right: 2px;
    }
    
    /* Shimmer effect for buttons */
    .media-actions .btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
    }
    
    .media-actions .btn:hover::before {
        left: 100%;
    }
    
    .availability-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8rem;
        font-weight: bold;
        margin-left: 0.5rem;
    }
    
    .availability-local {
        background-color: #4CAF50;
        color: white;
    }
    
    .availability-remote {
        background-color: #2196F3;
        color: white;
    }
    
    .availability-both {
        background-color: #FF9800;
        color: white;
    }
    
    .header-nav {
        display: flex;
        gap: 1rem;
        align-items: center;
    }
    
    .download-count {
        background-color: #4CAF50;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.7rem;
        font-weight: bold;
        margin-left: 0.5rem;
        min-width: 20px;
    }
    
    .controls {
        display: flex;
        gap: 1rem;
        margin-bottom: 2rem;
        flex-wrap: wrap;
    }
    
    .search-box {
        flex: 1;
        min-width: 200px;
        padding: 12px;
        border: 1px solid #555;
        border-radius: 4px;
        background-color: #2d2d2d;
        color: white;
        font-size: 16px;
    }
    
    .filter-select {
        padding: 12px;
        border: 1px solid #555;
        border-radius: 4px;
        background-color: #2d2d2d;
        color: white;
        font-size: 16px;
    }
    
    /* Enhanced Loading Indicator */
    .loading {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loading-content {
        background-color: #2d2d2d;
        border-radius: 16px;
        padding: 2rem;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        min-width: 300px;
        max-width: 90vw;
    }
    
    .loading-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid #333;
        border-top: 4px solid #4CAF50;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 1rem;
    }
    
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    
    #loadingText {
        font-size: 1.1rem;
        font-weight: 600;
        color: #ffffff;
        margin-bottom: 1rem;
    }
    
    .loading-progress {
        text-align: left;
        background-color: #1a1a1a;
        border-radius: 8px;
        padding: 1rem;
        margin-top: 1rem;
    }
    
    .progress-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
    }
    
    .progress-item:last-child {
        margin-bottom: 0;
    }
    
    .progress-label {
        font-size: 0.9rem;
        color: #ccc;
        font-weight: 500;
    }
    
    .progress-status {
        font-size: 0.9rem;
        font-weight: 600;
        padding: 2px 8px;
        border-radius: 12px;
    }
    
    .progress-status.loading {
        background-color: #2196F3;
        color: white;
        animation: pulse 1.5s infinite;
    }
    
    .progress-status.complete {
        background-color: #4CAF50;
        color: white;
    }
    
    .progress-status.error {
        background-color: #f44336;
        color: white;
    }
    
    .progress-status.waiting {
        background-color: #666;
        color: #ccc;
    }
    
    /* Enhanced progress status for progressive loading phases */
    .progress-status.checking {
        background-color: #FF9800;
        color: white;
        animation: pulse-checking 1.5s infinite;
    }
    
    .progress-status.ready {
        background-color: #4CAF50;
        color: white;
        animation: pulse-ready 2s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }
    
    @keyframes pulse-checking {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.8; transform: scale(1.05); }
    }
    
    @keyframes pulse-ready {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.9; }
    }
    
    /* Enhanced loading text with phase indicators */
    #loadingText {
        position: relative;
    }
    
    #loadingText::after {
        content: '';
        display: inline-block;
        width: 0;
        height: 0;
        margin-left: 8px;
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-bottom: 6px solid #4CAF50;
        animation: bounce 1s infinite;
        opacity: 0;
    }
    
    #loadingText.phase-active::after {
        opacity: 1;
    }
    
    @keyframes bounce {
        0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
        40% { transform: translateY(-4px); }
        60% { transform: translateY(-2px); }
    }

    /* Error Notification Styles */
    .error-notification-container {
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 10000;
        max-width: 400px;
        pointer-events: none;
    }

    .error-notification {
        background-color: #2d2d2d;
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 1rem;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        border-left: 4px solid #f44336;
        display: flex;
        align-items: flex-start;
        gap: 1rem;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.3s ease;
        pointer-events: auto;
        max-width: 100%;
    }

    .error-notification.show {
        opacity: 1;
        transform: translateX(0);
    }

    .error-notification.dismissing {
        opacity: 0;
        transform: translateX(100%);
    }

    .error-notification.severity-warning {
        border-left-color: #ff9800;
    }

    .error-notification.severity-info {
        border-left-color: #2196F3;
    }

    .error-notification.severity-success {
        border-left-color: #4CAF50;
    }

    .error-notification.severity-error {
        border-left-color: #f44336;
    }

    .error-icon {
        font-size: 1.5rem;
        flex-shrink: 0;
        margin-top: 0.25rem;
    }

    .error-content {
        flex: 1;
        min-width: 0;
    }

    .error-title {
        font-size: 1rem;
        font-weight: 600;
        color: #ffffff;
        margin-bottom: 0.5rem;
    }

    .error-message {
        font-size: 0.9rem;
        color: #ccc;
        line-height: 1.4;
        margin-bottom: 0.75rem;
    }

    .error-suggestions {
        margin-top: 0.75rem;
    }

    .error-suggestions ul {
        margin: 0;
        padding-left: 1.25rem;
        color: #aaa;
        font-size: 0.85rem;
    }

    .error-suggestions li {
        margin-bottom: 0.25rem;
        line-height: 1.3;
    }

    .error-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
        flex-shrink: 0;
    }

    .error-actions button {
        padding: 6px 12px;
        border: none;
        border-radius: 6px;
        font-size: 0.8rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        min-height: 32px;
    }

    .btn-retry {
        background-color: #4CAF50;
        color: white;
    }

    .btn-retry:hover {
        background-color: #388E3C;
    }

    .btn-dismiss {
        background-color: #666;
        color: white;
    }

    .btn-dismiss:hover {
        background-color: #555;
    }

    /* Enhanced Offline Mode Indicators */
    .system-status.offline {
        background-color: #3d2d1d;
        border: 2px solid #ff9800;
        animation: offline-pulse 3s infinite;
    }

    @keyframes offline-pulse {
        0%, 100% { 
            border-color: #ff9800;
            box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.4);
        }
        50% { 
            border-color: #f57c00;
            box-shadow: 0 0 0 4px rgba(255, 152, 0, 0.2);
        }
    }

    .offline-mode {
        background-color: rgba(255, 152, 0, 0.1);
        border: 1px solid #ff9800;
        border-radius: 8px;
        padding: 0.5rem 1rem;
        animation: offline-indicator-pulse 2s infinite;
    }

    @keyframes offline-indicator-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    /* Disabled offline features */
    .disabled-offline {
        opacity: 0.5;
        cursor: not-allowed !important;
        position: relative;
    }

    .disabled-offline::after {
        content: 'üåê';
        position: absolute;
        top: 2px;
        right: 2px;
        font-size: 0.7rem;
        opacity: 0.8;
    }

    /* Background Progress Indicators */
    .background-progress-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #2d2d2d;
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        max-width: 300px;
        z-index: 9999;
        opacity: 0;
        transform: translateY(100%);
        transition: all 0.3s ease;
    }

    .background-progress-container.show {
        opacity: 1;
        transform: translateY(0);
    }

    .background-progress-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
    }

    .background-progress-title {
        font-size: 0.9rem;
        font-weight: 600;
        color: #4CAF50;
    }

    .background-progress-close {
        background: none;
        border: none;
        color: #aaa;
        font-size: 1.2rem;
        cursor: pointer;
        padding: 0.25rem;
        border-radius: 4px;
        transition: all 0.2s ease;
    }

    .background-progress-close:hover {
        background-color: rgba(255, 255, 255, 0.1);
        color: white;
    }

    .background-progress-bar-container {
        width: 100%;
        height: 6px;
        background-color: #333;
        border-radius: 3px;
        overflow: hidden;
        margin-bottom: 0.75rem;
    }

    #backgroundProgressBar {
        height: 100%;
        background: linear-gradient(90deg, #4CAF50, #66BB6A);
        border-radius: 3px;
        transition: width 0.3s ease;
        position: relative;
    }

    #backgroundProgressBar::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        animation: progress-shine 2s infinite;
    }

    #backgroundProgressText {
        font-size: 0.85rem;
        color: #ccc;
        margin-bottom: 0.5rem;
    }

    #backgroundProgressDetails {
        font-size: 0.75rem;
        color: #aaa;
        margin-bottom: 0.5rem;
    }

    #backgroundProgressTime {
        font-size: 0.75rem;
        color: #888;
        font-style: italic;
    }

    /* Error state for loading text */
    #loadingText.error-state {
        color: #f44336;
        animation: error-pulse 2s infinite;
    }

    @keyframes error-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    @media (max-width: 768px) {
        .media-grid {
            grid-template-columns: 1fr;
        }
        
        .system-status {
            flex-direction: column;
            gap: 1rem;
        }
        
        .controls {
            flex-direction: column;
        }
        
        .media-actions {
            flex-direction: column;
        }
        
        .media-actions .btn {
            flex: none;
            min-width: 80px;
            font-size: 11px;
            padding: 8px 12px;
        }
        
        .media-actions .btn .btn-icon {
            font-size: 12px;
        }
        
        .loading-content {
            padding: 1.5rem;
            min-width: 280px;
        }
    }

    /* TV Show Hierarchy Styles */
    .tv-show-card {
        /* Inherits from .media-card */
    }

    .tv-show-seasons-view {
        width: 100%;
        max-width: none; /* Remove max-width constraint */
        margin: 0;
        padding: 20px;
        /* Ensure it takes full width of the container */
        grid-column: 1 / -1; /* Span all grid columns if parent is a grid */
        display: block; /* Override any flex/grid constraints */
    }

    .tv-show-header {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        margin-bottom: 30px;
        padding-bottom: 20px;
        border-bottom: 1px solid #444;
    }

    .show-header-content {
        display: flex;
        align-items: flex-start;
        gap: 20px;
        flex: 1;
    }

    .show-poster {
        flex-shrink: 0;
    }

    .show-poster-image {
        width: 120px;
        height: 180px;
        object-fit: cover;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .btn-back {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 16px;
        background: #555;
        color: #fff;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }

    .btn-back:hover {
        background: #4CAF50;
    }

    .show-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        min-height: 180px; /* Match poster height */
    }

    .show-info h2 {
        margin: 0 0 12px 0;
        color: #fff;
        font-size: 32px;
        font-weight: 600;
        line-height: 1.2;
    }

    .show-stats {
        color: #ccc;
        font-size: 18px;
        margin-bottom: 12px;
        font-weight: 500;
    }

    .show-availability-summary {
        color: #aaa;
        font-size: 14px;
        line-height: 1.4;
        margin-top: auto; /* Push to bottom of container */
    }

    .seasons-list {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .season-card {
        background: #2d2d2d;
        border: 1px solid #444;
        border-radius: 8px;
        overflow: hidden;
        transition: box-shadow 0.2s;
    }

    .season-card:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    .season-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .season-header:hover {
        background: #3d3d3d;
    }

    .season-info h3 {
        margin: 0 0 8px 0;
        color: #fff;
        font-size: 20px;
    }

    .season-stats {
        color: #ccc;
        font-size: 14px;
        margin-bottom: 8px;
    }

    .season-controls {
        display: flex;
        align-items: center;
        gap: 12px;
    }

    .expand-icon {
        font-size: 16px;
        color: #ccc;
        transition: transform 0.2s;
    }

    .season-episodes {
        border-top: 1px solid #444;
        background: #1d1d1d;
    }

    .episodes-list {
        padding: 0;
    }

    .episode-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 16px 20px;
        border-bottom: 1px solid #444;
        transition: background-color 0.2s;
    }

    .episode-item:last-child {
        border-bottom: none;
    }

    .episode-item:hover {
        background: #3d3d3d;
    }

    .episode-info {
        display: flex;
        align-items: center;
        gap: 16px;
        flex: 1;
    }

    .episode-number {
        background: #4CAF50;
        color: white;
        padding: 6px 10px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 12px;
        min-width: 40px;
        text-align: center;
    }

    .episode-details h4 {
        margin: 0 0 4px 0;
        color: #fff;
        font-size: 16px;
    }

    .episode-meta {
        color: #ccc;
        font-size: 12px;
    }

    .episode-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .availability-summary {
        color: #ccc;
        font-size: 12px;
        margin-top: 4px;
    }

    /* Availability indicators */
    .availability-indicator {
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: bold;
    }

    .availability-local {
        background: #2d5a2d;
        color: #90ee90;
    }

    .availability-remote {
        background: #1a4480;
        color: #87ceeb;
    }

    .availability-both {
        background: #8b4513;
        color: #ffd700;
    }

    .availability-mixed {
        background: #5a2d8b;
        color: #dda0dd;
    }

    .availability-none {
        background: #8b2d2d;
        color: #ffb6c1;
    }

    .no-episodes {
        padding: 20px;
        text-align: center;
        color: #ccc;
        font-style: italic;
    }

    /* Responsive design for TV show seasons */
    @media (max-width: 768px) {
        .show-header-content {
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .show-poster-image {
            width: 100px;
            height: 150px;
        }

        .show-info {
            min-height: auto;
            align-items: center;
        }

        .show-info h2 {
            font-size: 24px;
            text-align: center;
        }

        .show-stats {
            font-size: 16px;
            text-align: center;
        }

        .tv-show-seasons-view {
            padding: 15px;
        }

        .season-header {
            padding: 15px;
        }

        .episode-item {
            padding: 12px 15px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="system-status" id="systemStatus">
    <div class="status-item">
        <span class="status-indicator" id="internetStatus">üåê</span>
        <span id="internetText">Internet: Checking...</span>
    </div>
    <div class="status-item">
        <span class="status-indicator {% if system_status.jellyfin_connected %}status-online{% else %}status-offline{% endif %}" id="jellyfinStatus"></span>
        <span id="jellyfinText">Jellyfin: {% if system_status.jellyfin_connected %}Connected{% else %}Offline{% endif %}</span>
    </div>
    <div class="status-item">
        <span class="status-indicator {% if system_status.vlc_available %}status-online{% else %}status-offline{% endif %}" id="vlcStatus"></span>
        <span id="vlcText">VLC: {% if system_status.vlc_available %}Available{% else %}Not Found{% endif %}</span>
    </div>
    <div class="status-item">
        <span class="status-indicator {% if system_status.services_ready %}status-online{% else %}status-offline{% endif %}" id="servicesStatus"></span>
        <span id="servicesText">Services: {% if system_status.services_ready %}Ready{% else %}Not Ready{% endif %}</span>
    </div>
    <div class="status-item offline-mode" id="offlineMode" style="display: none;">
        <span class="status-indicator status-warning">üì±</span>
        <span>Offline Mode: Active</span>
    </div>
</div>

<!-- Background Progress Indicator -->
<div id="backgroundProgressContainer" class="background-progress-container" style="display: none;">
    <div class="background-progress-header">
        <div class="background-progress-title">Background Loading</div>
        <button class="background-progress-close" onclick="hideBackgroundProgress()">√ó</button>
    </div>
    <div class="background-progress-bar-container">
        <div id="backgroundProgressBar" style="width: 0%;"></div>
    </div>
    <div id="backgroundProgressText">Initializing...</div>
    <div id="backgroundProgressDetails" style="display: none;"></div>
    <div id="backgroundProgressTime" style="display: none;"></div>
</div>

<div class="controls">
    <input type="text" id="searchBox" class="search-box" placeholder="Search media...">
    <select id="filterSelect" class="filter-select">
        <option value="local">Local Only</option>
        <option value="remote">Remote Only</option>
        <option value="both">Available Both</option>
        <option selected value="movies">Movies</option>
        <option value="tv">TV Shows</option>
    </select>
    <button class="btn" onclick="refreshLibrary()">Refresh</button>
    <button class="btn btn-secondary" onclick="syncLibraries()">Sync</button>
    <button class="btn btn-secondary" onclick="toggleDownloadQueue()" id="downloadQueueBtn" style="display: none;">
        <span>‚¨áÔ∏è</span> Downloads <span class="download-count" id="downloadCount">0</span>
    </button>
</div>

<div id="loadingIndicator" class="loading" style="display: none;">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <p id="loadingText">Loading media library...</p>
        <div id="loadingProgress" class="loading-progress" style="display: none;">
            <div class="progress-item">
                <span class="progress-label">Local media:</span>
                <span id="localProgress" class="progress-status">Loading...</span>
            </div>
            <div class="progress-item">
                <span class="progress-label">Remote media:</span>
                <span id="remoteProgress" class="progress-status">Waiting...</span>
            </div>
        </div>
    </div>
</div>

<div id="mainMediaSectionHeader" class="section-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding-bottom: 0.5rem; border-bottom: 2px solid #4CAF50;">
    <h2 id="mainMediaSectionTitle" class="section-title">Movies</h2> <span id="mainMediaSectionCount" class="section-count">0</span> </div>

<div id="mediaGrid" class="media-grid">
    </div>

<div id="noMedia" style="display: none; text-align: center; padding: 2rem; color: #aaa;">
    <p>No media found. Check your configuration or add some media files.</p>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/status-manager.js') }}"></script>
<script>
let mediaData = [];
let filteredData = [];

// Status Management with StatusManager
let statusManager = null;
let connectivityStatus = {
    internet: false,
    jellyfin: false,
    vlc: false,
    services: false,
    lastCheck: null,
    offlineMode: false,
    jellyfinConfirmed: false // Track if Jellyfin was previously confirmed as available
};

// Track status check progress for better user feedback
let statusCheckProgress = {
    internet: { status: 'pending', startTime: null, duration: null },
    jellyfin: { status: 'pending', startTime: null, duration: null },
    vlc: { status: 'pending', startTime: null, duration: null },
    totalStartTime: null
};

// Initialize StatusManager on page load
async function initializeStatusManager() {
    try {
        console.log('Initializing StatusManager...');
        statusManager = new StatusManager({
            internetCheckTimeout: 3000,
            jellyfinCheckTimeout: 5000,
            fastCheckInterval: 10000,
            slowCheckInterval: 60000
        });
        
        // Set up 10-second timeout to ensure accurate status display
        const statusTimeout = setTimeout(() => {
            console.log('Status display timeout reached - ensuring all services have final status');
            ensureAccurateStatusDisplay();
        }, 10000);
        
        // Set up event listeners for status changes with real-time updates
        statusManager.on('initialized', (status) => {
            console.log('StatusManager initialized:', status);
            updateConnectivityStatusFromManager(status);
            
            // Update individual service statuses with real-time feedback
            updateServiceStatus('internet', status.internet?.connected, { method: status.internet?.method });
            updateServiceStatus('jellyfin', status.jellyfin?.connected, { serverUrl: status.jellyfin?.serverUrl });
            updateServiceStatus('vlc', status.vlc?.available, { path: status.vlc?.path });
            
            updateSystemStatusDisplay(convertStatusManagerToLegacyFormat(status));
        });
        
        statusManager.on('connectivityChange', (data) => {
            console.log('Connectivity changed:', data);
            const currentStatus = statusManager.getStatus();
            updateConnectivityStatusFromManager(currentStatus);
            
            // Update the specific service that changed with real-time feedback
            const { service, connected } = data;
            if (service === 'internet') {
                updateServiceStatus('internet', connected, { method: currentStatus.internet?.method });
            } else if (service === 'jellyfin') {
                updateServiceStatus('jellyfin', connected, { serverUrl: currentStatus.jellyfin?.serverUrl });
            }
            
            updateSystemStatusDisplay(convertStatusManagerToLegacyFormat(currentStatus));
        });
        
        statusManager.on('availabilityChange', (data) => {
            console.log('Service availability changed:', data);
            const currentStatus = statusManager.getStatus();
            updateConnectivityStatusFromManager(currentStatus);
            
            // Update the specific service that changed
            const { service, available } = data;
            if (service === 'vlc') {
                updateServiceStatus('vlc', available, { path: currentStatus.vlc?.path });
            } else if (service === 'localMedia') {
                // Handle local media availability changes if needed
                console.log('Local media availability changed:', available);
            }
            
            updateSystemStatusDisplay(convertStatusManagerToLegacyFormat(currentStatus));
        });
        
        statusManager.on('connectivityModeChange', (data) => {
            console.log('Connectivity mode changed:', data);
            handleConnectivityModeChange(data);
        });
        
        // Add periodic check complete handler for real-time updates
        statusManager.on('periodicCheckComplete', (data) => {
            console.log('Periodic status check completed:', data);
            const currentStatus = statusManager.getStatus();
            
            // Update individual service statuses with latest data
            updateServiceStatus('internet', currentStatus.internet?.connected, { method: currentStatus.internet?.method });
            updateServiceStatus('jellyfin', currentStatus.jellyfin?.connected, { serverUrl: currentStatus.jellyfin?.serverUrl });
            updateServiceStatus('vlc', currentStatus.vlc?.available, { path: currentStatus.vlc?.path });
            
            updateConnectivityStatusFromManager(currentStatus);
            updateSystemStatusDisplay(convertStatusManagerToLegacyFormat(currentStatus));
        });
        
        // Initialize the status manager
        await statusManager.initialize();
        
        // Clear the timeout since initialization completed successfully
        clearTimeout(statusTimeout);
        
        // Start adaptive polling for background monitoring
        statusManager.startAdaptivePolling({
            initialInterval: 10000,
            maxInterval: 60000,
            services: ['internet', 'jellyfin']
        });
        
        return statusManager;
        
    } catch (error) {
        console.error('Failed to initialize StatusManager:', error);
        // Fallback to legacy status checking
        return null;
    }
}

// Convert StatusManager format to legacy format for compatibility
function convertStatusManagerToLegacyFormat(status) {
    return {
        services: {
            jellyfin: {
                connected: status.jellyfin?.connected || false,
                server_url: status.jellyfin?.serverUrl || null
            },
            vlc: {
                installed: status.vlc?.available || false,
                path: status.vlc?.path || null
            }
        },
        services_ready: (status.internet?.connected && status.jellyfin?.connected && status.vlc?.available) || false
    };
}

// Update connectivityStatus object from StatusManager data
function updateConnectivityStatusFromManager(status) {
    connectivityStatus.internet = status.internet?.connected || false;
    connectivityStatus.jellyfin = status.jellyfin?.connected || false;
    connectivityStatus.vlc = status.vlc?.available || false;
    connectivityStatus.services = (connectivityStatus.internet && connectivityStatus.jellyfin && connectivityStatus.vlc);
    connectivityStatus.lastCheck = new Date();
    connectivityStatus.jellyfinConfirmed = status.jellyfin?.connected || false;
    
    // Update offline mode based on internet connectivity
    const wasOffline = connectivityStatus.offlineMode;
    connectivityStatus.offlineMode = !connectivityStatus.internet;
    
    if (wasOffline && connectivityStatus.internet) {
        handleOnlineEvent();
    } else if (!wasOffline && !connectivityStatus.internet) {
        handleOfflineEvent();
    }
}

// Show loading state for individual service during checks
function setServiceLoadingState(service, isLoading = true, message = null) {
    const statusElement = document.getElementById(`${service}Status`);
    const textElement = document.getElementById(`${service}Text`);
    
    if (!statusElement || !textElement) return;
    
    if (isLoading) {
        statusElement.className = 'status-indicator status-checking';
        const loadingMessage = message || `${service.charAt(0).toUpperCase() + service.slice(1)}: Checking...`;
        textElement.textContent = loadingMessage;
        textElement.title = `Checking ${service} status...`;
        
        // Track progress
        statusCheckProgress[service] = {
            status: 'checking',
            startTime: Date.now(),
            duration: null
        };
        
        if (!statusCheckProgress.totalStartTime) {
            statusCheckProgress.totalStartTime = Date.now();
        }
    }
}

// Update individual service status with real-time feedback
function updateServiceStatus(service, connected, details = {}) {
    const statusElement = document.getElementById(`${service}Status`);
    const textElement = document.getElementById(`${service}Text`);
    const timestamp = new Date().toLocaleTimeString();
    
    if (!statusElement || !textElement) return;
    
    const serviceName = service.charAt(0).toUpperCase() + service.slice(1);
    
    // Track completion time
    if (statusCheckProgress[service] && statusCheckProgress[service].startTime) {
        statusCheckProgress[service].duration = Date.now() - statusCheckProgress[service].startTime;
        statusCheckProgress[service].status = connected ? 'connected' : 'offline';
    }
    
    if (connected) {
        statusElement.className = 'status-indicator status-online';
        
        // Customize text based on service type and available details
        let statusText = `${serviceName}: Connected`;
        if (service === 'jellyfin' && details.serverUrl) {
            statusText = `${serviceName}: Connected (${details.serverUrl})`;
        } else if (service === 'vlc' && details.path) {
            statusText = `${serviceName}: Available (${details.path})`;
        } else if (service === 'internet') {
            statusText = `${serviceName}: Connected`;
        }
        
        textElement.textContent = statusText;
        textElement.title = `${serviceName} is ${service === 'vlc' ? 'available' : 'connected'} - Last checked: ${timestamp}`;
    } else {
        statusElement.className = 'status-indicator status-offline';
        
        let statusText = `${serviceName}: Offline`;
        if (service === 'vlc') {
            statusText = `${serviceName}: Not Found`;
        } else if (service === 'internet') {
            statusText = `${serviceName}: Offline`;
        }
        
        textElement.textContent = statusText;
        textElement.title = `${serviceName} is ${service === 'vlc' ? 'not available' : 'offline'} - Last checked: ${timestamp}`;
    }
    
    // Log performance metrics for debugging
    if (statusCheckProgress[service] && statusCheckProgress[service].duration) {
        console.log(`Status check for ${service} completed in ${statusCheckProgress[service].duration}ms`);
    }
}

// Handle connectivity mode changes from StatusManager
function handleConnectivityModeChange(data) {
    const { oldMode, newMode, internet, jellyfin } = data;
    
    console.log(`Connectivity mode changed: ${oldMode} -> ${newMode}`);
    
    // Update system status display based on mode
    const systemStatus = document.getElementById('systemStatus');
    if (systemStatus) {
        systemStatus.className = 'system-status';
        
        if (newMode === 'offline') {
            systemStatus.classList.add('offline');
        } else if (newMode === 'degraded') {
            systemStatus.classList.add('degraded');
        }
    }
    
    // Show/hide offline mode indicator
    const offlineMode = document.getElementById('offlineMode');
    if (offlineMode) {
        if (newMode === 'offline') {
            offlineMode.style.display = 'flex';
        } else {
            offlineMode.style.display = 'none';
        }
    }
    
    // Emit custom events for other parts of the application
    window.dispatchEvent(new CustomEvent('connectivityModeChange', {
        detail: { oldMode, newMode, internet, jellyfin }
    }));
}

// Try to load jellyfinConfirmed from localStorage (legacy compatibility)
try {
    const savedJellyfinConfirmed = localStorage.getItem('jellyfinConfirmed');
    const savedTimestamp = localStorage.getItem('jellyfinConfirmedTimestamp');
    
    if (savedJellyfinConfirmed === 'true' && savedTimestamp) {
        // Only use the saved value if it's less than 24 hours old
        const timestamp = parseInt(savedTimestamp, 10);
        const now = Date.now();
        const ageInHours = (now - timestamp) / (1000 * 60 * 60);
        
        if (ageInHours < 24) {
            // Don't set it immediately - let the initial page load do a full check first
            // This will be used by periodic checks after the initial load
            console.log(`Found cached jellyfinConfirmed=true from localStorage (${ageInHours.toFixed(1)} hours old) - will use for periodic checks`);
        } else {
            console.log(`Saved jellyfinConfirmed is too old (${ageInHours.toFixed(1)} hours), clearing`);
            localStorage.removeItem('jellyfinConfirmed');
            localStorage.removeItem('jellyfinConfirmedTimestamp');
        }
    }
} catch (e) {
    console.warn('Failed to load jellyfinConfirmed from localStorage:', e);
}

let statusCheckInterval = null;
let connectivityCheckInterval = null;

// Load media library on page load
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOMContentLoaded - initializing application');
    
    // Initialize connectivity monitoring with StatusManager
    await initializeConnectivityMonitoring();
    
    // Load media library (this will now be non-blocking)
    loadMediaLibrary();
    
    // Set up search and filter handlers
    document.getElementById('searchBox').addEventListener('input', filterMedia);
    document.getElementById('filterSelect').addEventListener('change', filterMedia);
});

// Function to update status indicator without blocking modal
function updateStatusIndicator(message, status = 'loading') {
    // Update the Jellyfin status in the status bar
    const jellyfinText = document.getElementById('jellyfinText');
    const jellyfinStatus = document.getElementById('jellyfinStatus');

    if (jellyfinText && jellyfinStatus) {
        if (status === 'loading') {
            jellyfinStatus.className = 'status-indicator status-checking';
            jellyfinText.textContent = `Jellyfin: ${message}`;
        } else if (status === 'connected') {
            jellyfinStatus.className = 'status-indicator status-online';
            jellyfinText.textContent = `Jellyfin: ${message}`;
        } else if (status === 'error' || status === 'offline') {
            jellyfinStatus.className = 'status-indicator status-offline';
            jellyfinText.textContent = `Jellyfin: ${message}`;
        }
    }

    console.log(`Status indicator updated: ${message} (${status})`);
}

async function loadMediaLibrary(forceRefresh = false) {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const mediaGrid = document.getElementById('mediaGrid');
    const noMedia = document.getElementById('noMedia');
    const mainSectionCount = document.getElementById('mainMediaSectionCount');

    // Initialize progressive loader if not already done
    if (!window.progressiveLoader) {
        window.progressiveLoader = new ProgressiveMediaLoader();
        
        // Set up progressive loading callbacks
        window.progressiveLoader.setCallbacks({
            onLocalLoaded: (localMedia, unifiedMedia) => {
                console.log('Progressive loading: Local media loaded', localMedia.length, 'items');
                
                // Update media data with local items
                mediaData = unifiedMedia;
                
                // Update status indicator instead of showing blocking modal phases
                updateStatusIndicator(`${localMedia.length} local items loaded`, 'connected');
                
                // Update media count display
                if (mainSectionCount) {
                    mainSectionCount.textContent = localMedia.length;
                }
                
                // Filter and render local media immediately
                filterMedia();
                
                // Don't show message here - will be shown by onUserInteractionEnabled callback

                // Update status to show we're now checking remote services
                // Use a flag to prevent overriding successful connection status
                window.remoteLoadingInProgress = true;
                setTimeout(() => {
                    if (window.remoteLoadingInProgress) {
                        updateStatusIndicator('Checking remote services...', 'loading');
                    }
                }, 1000);
            },
            
            onRemoteLoaded: (remoteMedia, unifiedMedia) => {
                console.log('Progressive loading: Remote media loaded', remoteMedia.length, 'items');

                // Clear the remote loading flag to prevent status override
                window.remoteLoadingInProgress = false;

                // Update media data with unified list
                mediaData = unifiedMedia;

                // Update status indicator for remote loading completion
                const localCount = unifiedMedia.filter(item => item.has_local).length;
                updateStatusIndicator(`Connected - ${remoteMedia.length} remote items loaded`, 'connected');
                
                // Update media count display
                if (mainSectionCount) {
                    mainSectionCount.textContent = unifiedMedia.length;
                }
                
                // Filter and render unified media
                filterMedia();
                
                // Show success message for remote loading
                if (remoteMedia.length > 0) {
                    showMessage(`Loaded ${remoteMedia.length} remote media items in background`, 'success');
                }
            },
            
            onComplete: (unifiedMedia) => {
                console.log('Progressive loading: Complete with', unifiedMedia.length, 'total items');

                // Clear the remote loading flag
                window.remoteLoadingInProgress = false;

                // Final update of media data
                mediaData = unifiedMedia;

                // Calculate final statistics
                const localCount = unifiedMedia.filter(item => item.has_local).length;
                const remoteCount = unifiedMedia.filter(item => item.has_remote).length;
                const totalLoadingTime = Date.now() - (window.loadingStartTime || Date.now());

                // Update final status - no blocking modal needed
                updateStatusIndicator(`Connected - ${unifiedMedia.length} total items`, 'connected');

                // Don't show completion message here - already shown by onRemoteLoaded

                // Update media count display
                if (mainSectionCount) {
                    mainSectionCount.textContent = unifiedMedia.length;
                }

                // Final filter and render
                filterMedia();

                // Cache the unified data for offline use
                try {
                    localStorage.setItem('mediaCache', JSON.stringify({
                        media: unifiedMedia,
                        timestamp: Date.now()
                    }));
                } catch (cacheError) {
                    console.warn('Failed to cache unified media data:', cacheError);
                }
            },
            
            onError: (error, errorInfo) => {
                console.error('Progressive loading error:', error, errorInfo);

                // Clear the remote loading flag
                window.remoteLoadingInProgress = false;

                // Check if we actually have remote items loaded despite the error
                const currentRemoteCount = mediaData.filter(item => item.has_remote).length;
                if (currentRemoteCount > 0) {
                    console.log('Remote items are actually loaded, ignoring false error message');
                    return; // Don't show error if remote items are actually present
                }

                // Display user-friendly error message only for real errors
                if (errorInfo && errorInfo.service) {
                    progressiveLoader.displayServiceUnavailabilityMessage(errorInfo);
                }

                // Handle different types of errors with appropriate indicators
                if (error.message.includes('Remote media unavailable') || error.message.includes('services unavailable')) {
                    // Remote loading failed, but local succeeded
                    const localCount = mediaData.length || 0;
                    updateStatusIndicator('Offline - remote services unavailable', 'offline');

                    showMessage('Remote services unavailable - local content ready for use', 'warning');
                    
                } else if (error.message.includes('Local media loading timeout') || error.message.includes('local')) {
                    // Local loading failed - try cache
                    updateStatusIndicator('Error loading local media', 'error');
                    showMessage('Local media loading slow - trying cache...', 'warning');

                    if (!tryLoadFromCache()) {
                        updateStatusIndicator('Failed to load local media', 'error');
                        showMessage('Failed to load local media', 'error');
                    }
                    
                } else {
                    // Complete failure - try to load from cache
                    updateStatusIndicator('Loading failed - trying cache...', 'error');
                    showMessage('Failed to load media library - trying cache...', 'error');

                    if (!tryLoadFromCache()) {
                        // If cache also fails, show error state
                        updateStatusIndicator('Failed to load media library', 'error');
                        showMessage('Failed to load media library', 'error');
                    } else {
                        // Cache succeeded
                        const cachedCount = mediaData.length || 0;
                        updateStatusIndicator(`Loaded ${cachedCount} items from cache`, 'connected');
                        showMessage(`Loaded ${cachedCount} items from cache`, 'success');
                    }
                }
            },
            
            onLoadingStateChange: (loadingStates, message, indicators) => {
                console.log('Loading state change:', message, loadingStates, indicators);
                
                // Update background progress if indicators are provided for background tasks
                if (indicators && indicators.isBackgroundTask && indicators.progress) {
                    updateBackgroundProgress(
                        indicators.progress.percentage,
                        indicators.message,
                        indicators.detailedMessage,
                        indicators.timeEstimate
                    );
                }
                
                // Use loading indicators if available
                if (indicators && indicators.phase) {
                    showProgressiveLoadingPhase(indicators.phase, indicators.progress);
                } else {
                    updateLoadingIndicator(message, true);
                }
                
                // Update individual progress based on loading states
                if (loadingStates.local && loadingStates.local.status === 'loading') {
                    updateProgressStatus('local', 'Loading...', loadingStates.local.count);
                    updateProgressStatus('remote', 'Waiting...');
                } else if (loadingStates.remote && loadingStates.remote.status === 'loading') {
                    updateProgressStatus('local', 'Complete', loadingStates.local?.count);
                    updateProgressStatus('remote', 'Loading...', loadingStates.remote.count);
                }
            },
            
            onUserInteractionEnabled: (data) => {
                console.log('User interaction enabled:', data);
                
                // Show that user can now interact while background loading continues
                if (data.localMediaCount > 0) {
                    showMessage(`${data.localMediaCount} local items ready - you can browse while remote content loads`, 'info');
                }
                
                // Enable UI interactions (remove any disabled states)
                document.body.classList.remove('loading-disabled');
                
                // Update loading indicator to show interaction is enabled
                const currentText = document.getElementById('loadingText')?.textContent || '';
                if (!currentText.includes('interaction enabled')) {
                    updateLoadingIndicator(currentText + ' - interaction enabled', true);
                }
            },
            
            onBackgroundTasksStarted: (options) => {
                console.log('Background tasks started:', options);
                
                // Show background progress indicator
                if (options.showProgressIndicators) {
                    showBackgroundProgress(true);
                    updateBackgroundProgress(0, 'Starting background loading...', 'Checking remote services...');
                }
                
                // Show that background loading has started
                showProgressiveLoadingPhase('checking_remote', { 
                    localCount: mediaData.length 
                });
            },
            
            onBackgroundTasksCompleted: (results) => {
                console.log('Background tasks completed:', results);
                
                // Hide background progress indicator
                setTimeout(() => {
                    hideBackgroundProgress();
                }, 2000);
                
                // Background loading completed - this will be handled by onComplete callback
                // Just log for debugging purposes
            }
        });
    }

    // Clear previous content but DON'T show blocking modal immediately
    mediaGrid.innerHTML = '';
    noMedia.style.display = 'none';
    // loadingIndicator.style.display = 'block'; // REMOVED - no blocking modal on startup

    // Track loading start time for performance metrics
    window.loadingStartTime = Date.now();

    // Show a subtle loading indicator in the status bar instead of blocking modal
    updateStatusIndicator('Loading local media...', 'loading');

    console.log('Starting non-blocking progressive loading - local files will show immediately');

    console.log('Starting progressive media loading...');

    try {
        // Use progressive loader with indicators
        await window.progressiveLoader.loadMedia(forceRefresh);
        
    } catch (error) {
        console.error('Progressive loading failed:', error);
        updateStatusIndicator('Loading failed', 'error');
        showMessage('Failed to load media library', 'error');

        // Fallback to cache if progressive loading fails completely
        if (!tryLoadFromCache()) {
            // If cache also fails, show no media message
            noMedia.style.display = 'block';
        }
        // No need to hide loadingIndicator since we're not showing it
    }

    console.log('Progressive media loading complete');
}

// Update loading indicator text and progress
function updateLoadingIndicator(message, showProgress = false, phase = null, stats = null) {
    const loadingIndicator = document.getElementById('loadingIndicator');
    const loadingText = document.getElementById('loadingText');
    const loadingProgress = document.getElementById('loadingProgress');
    const localProgress = document.getElementById('localProgress');
    const remoteProgress = document.getElementById('remoteProgress');
    
    if (loadingText) {
        loadingText.textContent = message;
    }
    
    if (loadingProgress) {
        loadingProgress.style.display = showProgress ? 'block' : 'none';
    }
    
    // Enhanced progress indicators with progressive loading phases
    if (localProgress && remoteProgress) {
        // Phase 1: Loading local media (immediate display)
        if (message.includes('Loading local media') || phase === 'loading_local') {
            localProgress.textContent = 'Loading...';
            localProgress.className = 'progress-status loading';
            remoteProgress.textContent = 'Waiting...';
            remoteProgress.className = 'progress-status waiting';
            if (loadingProgress) loadingProgress.style.display = 'block';
            
        // Phase 2: Local media loaded, checking remote services
        } else if (message.includes('Checking remote services') || phase === 'checking_remote') {
            const localCount = stats?.localCount || '';
            localProgress.textContent = `Complete${localCount ? ` (${localCount})` : ''}`;
            localProgress.className = 'progress-status complete';
            remoteProgress.textContent = 'Checking services...';
            remoteProgress.className = 'progress-status loading';
            if (loadingProgress) loadingProgress.style.display = 'block';
            
        // Phase 3: Loading remote media in background
        } else if (message.includes('Loading remote media') || phase === 'loading_remote') {
            const localCount = stats?.localCount || '';
            localProgress.textContent = `Complete${localCount ? ` (${localCount})` : ''}`;
            localProgress.className = 'progress-status complete';
            remoteProgress.textContent = 'Loading...';
            remoteProgress.className = 'progress-status loading';
            if (loadingProgress) loadingProgress.style.display = 'block';
            
        // Phase 4: Remote services unavailable
        } else if (message.includes('Remote media unavailable') || message.includes('services unavailable') || phase === 'remote_unavailable') {
            const localCount = stats?.localCount || '';
            localProgress.textContent = `Complete${localCount ? ` (${localCount})` : ''}`;
            localProgress.className = 'progress-status complete';
            remoteProgress.textContent = 'Unavailable';
            remoteProgress.className = 'progress-status error';
            if (loadingProgress) loadingProgress.style.display = 'block';
            
        // Phase 5: All loading complete with final status summary
        } else if (message.includes('Loading complete') || phase === 'complete') {
            const localCount = stats?.localCount || '';
            const remoteCount = stats?.remoteCount || '';
            const totalCount = stats?.totalCount || '';
            
            localProgress.textContent = `Complete${localCount ? ` (${localCount})` : ''}`;
            localProgress.className = 'progress-status complete';
            remoteProgress.textContent = `Complete${remoteCount ? ` (${remoteCount})` : ''}`;
            remoteProgress.className = 'progress-status complete';
            
            // Update main text with final summary
            if (loadingText && totalCount) {
                loadingText.textContent = `Loading complete - ${totalCount} items available`;
            }
            
            if (loadingProgress) loadingProgress.style.display = 'block';
        }
    }
}

// Update individual progress status
function updateProgressStatus(type, status, count = null, details = null) {
    const progressElement = document.getElementById(`${type}Progress`);
    if (progressElement) {
        let statusText = status;
        
        // Add count information if provided
        if (count !== null) {
            statusText += ` (${count})`;
        }
        
        // Add additional details for enhanced feedback
        if (details) {
            if (details.duration) {
                statusText += ` - ${Math.round(details.duration / 1000)}s`;
            }
            if (details.error) {
                statusText += ` - ${details.error}`;
            }
        }
        
        progressElement.textContent = statusText;
        
        // Enhanced CSS class assignment based on status
        if (status.toLowerCase().includes('loading') || status.toLowerCase().includes('checking')) {
            progressElement.className = 'progress-status loading';
        } else if (status.toLowerCase().includes('complete')) {
            progressElement.className = 'progress-status complete';
        } else if (status.toLowerCase().includes('error') || status.toLowerCase().includes('unavailable') || status.toLowerCase().includes('failed')) {
            progressElement.className = 'progress-status error';
        } else if (status.toLowerCase().includes('waiting') || status.toLowerCase().includes('pending')) {
            progressElement.className = 'progress-status waiting';
        } else {
            progressElement.className = 'progress-status waiting';
        }
    }
}

// New function to create final status summary display
function createFinalStatusSummary(stats) {
    const summary = {
        totalItems: (stats.localCount || 0) + (stats.remoteCount || 0),
        localItems: stats.localCount || 0,
        remoteItems: stats.remoteCount || 0,
        loadingTime: stats.totalLoadingTime || 0,
        connectivityMode: stats.connectivityMode || 'unknown'
    };
    
    let summaryText = `Loading complete - ${summary.totalItems} items available`;
    
    if (summary.localItems > 0 && summary.remoteItems > 0) {
        summaryText += ` (${summary.localItems} local, ${summary.remoteItems} remote)`;
    } else if (summary.localItems > 0 && summary.remoteItems === 0) {
        summaryText += ` (local only)`;
    } else if (summary.remoteItems > 0 && summary.localItems === 0) {
        summaryText += ` (remote only)`;
    }
    
    if (summary.loadingTime > 0) {
        summaryText += ` in ${Math.round(summary.loadingTime / 1000)}s`;
    }
    
    return {
        text: summaryText,
        stats: summary
    };
}

// Show progressive loading phases
function showProgressiveLoadingPhase(phase, data = {}) {
    const phases = {
        'initializing': {
            message: 'Initializing media loading...',
            showProgress: true,
            phase: 'initializing',
            duration: 500
        },
        'loading_local': {
            message: 'Loading local media...',
            showProgress: true,
            phase: 'loading_local',
            duration: 2000
        },
        'local_complete': {
            message: `Local media loaded (${data.localCount || 0} items) - interaction enabled`,
            showProgress: true,
            phase: 'local_complete',
            stats: { localCount: data.localCount },
            duration: 1000
        },
        'checking_remote': {
            message: 'Checking remote services...',
            showProgress: true,
            phase: 'checking_remote',
            stats: { localCount: data.localCount },
            duration: 3000
        },
        'loading_remote': {
            message: 'Loading remote media in background...',
            showProgress: true,
            phase: 'loading_remote',
            stats: { localCount: data.localCount },
            duration: 5000
        },
        'remote_unavailable': {
            message: `Remote services unavailable - ${data.localCount || 0} local items ready`,
            showProgress: true,
            phase: 'remote_unavailable',
            stats: { localCount: data.localCount },
            duration: 2000
        },
        'complete': {
            message: 'Loading complete',
            showProgress: true,
            phase: 'complete',
            stats: {
                localCount: data.localCount,
                remoteCount: data.remoteCount,
                totalCount: (data.localCount || 0) + (data.remoteCount || 0),
                totalLoadingTime: data.totalLoadingTime
            },
            duration: 2000
        },
        'checking_connectivity': {
            message: 'Checking remote services...',
            showProgress: true,
            phase: 'checking_connectivity',
            stats: { localCount: data.localCount },
            duration: 2000
        },
        'connectivity_checked': {
            message: 'Remote services checked',
            showProgress: true,
            phase: 'connectivity_checked',
            stats: { localCount: data.localCount },
            duration: 1000
        },
        'loading_remote_data': {
            message: 'Loading remote media in background...',
            showProgress: true,
            phase: 'loading_remote_data',
            stats: { localCount: data.localCount },
            duration: 5000
        },
        'remote_complete': {
            message: 'Remote media loaded',
            showProgress: true,
            phase: 'remote_complete',
            stats: { 
                localCount: data.localCount,
                remoteCount: data.remoteCount 
            },
            duration: 1000
        },
        'remote_loading_complete': {
            message: `Background loading complete${data.remoteCount ? ` (${data.remoteCount} remote items)` : ''}`,
            showProgress: true,
            phase: 'remote_loading_complete',
            stats: { 
                localCount: data.localCount,
                remoteCount: data.remoteCount 
            },
            duration: 2000
        },
        'remote_loading_error': {
            message: `Background loading failed${data.error ? `: ${data.error}` : ''}`,
            showProgress: true,
            phase: 'remote_loading_error',
            stats: { localCount: data.localCount },
            duration: 2000
        },
        'unified_complete': {
            message: 'All media loaded',
            showProgress: true,
            phase: 'unified_complete',
            stats: {
                localCount: data.localCount,
                remoteCount: data.remoteCount,
                totalCount: (data.localCount || 0) + (data.remoteCount || 0)
            },
            duration: 2000
        },
        'error': {
            message: 'Loading error occurred',
            showProgress: true,
            phase: 'error',
            stats: { error: data.error },
            duration: 3000
        }
    };
    
    const phaseConfig = phases[phase];
    if (phaseConfig) {
        // Add visual feedback to loading text
        const loadingText = document.getElementById('loadingText');
        if (loadingText) {
            loadingText.classList.add('phase-active');
            setTimeout(() => {
                loadingText.classList.remove('phase-active');
            }, phaseConfig.duration || 1000);
        }
        
        // Update the loading indicator with enhanced information
        updateLoadingIndicator(phaseConfig.message, phaseConfig.showProgress, phaseConfig.phase, phaseConfig.stats);
        
        // Update progress status based on phase
        const localProgress = document.getElementById('localProgress');
        const remoteProgress = document.getElementById('remoteProgress');
        
        if (localProgress && remoteProgress) {
            switch (phase) {
                case 'initializing':
                    updateProgressStatus('local', 'Waiting...', null, null);
                    updateProgressStatus('remote', 'Waiting...', null, null);
                    break;
                case 'loading_local':
                    updateProgressStatus('local', 'Loading...', null, null);
                    updateProgressStatus('remote', 'Waiting...', null, null);
                    break;
                case 'local_complete':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Waiting...', null, null);
                    break;
                case 'checking_remote':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Checking...', null, null);
                    remoteProgress.className = 'progress-status checking';
                    break;
                case 'loading_remote':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Loading...', null, null);
                    break;
                case 'remote_unavailable':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Unavailable', null, { error: 'Service offline' });
                    break;
                case 'complete':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Complete', data.remoteCount, null);
                    localProgress.className = 'progress-status ready';
                    remoteProgress.className = 'progress-status ready';
                    break;
                case 'checking_connectivity':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Checking...', null, null);
                    remoteProgress.className = 'progress-status checking';
                    break;
                case 'connectivity_checked':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Checked', null, null);
                    break;
                case 'loading_remote_data':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Loading...', null, null);
                    remoteProgress.className = 'progress-status loading';
                    break;
                case 'remote_complete':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Complete', data.remoteCount, null);
                    remoteProgress.className = 'progress-status ready';
                    break;
                case 'remote_loading_complete':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Complete', data.remoteCount, null);
                    remoteProgress.className = 'progress-status ready';
                    break;
                case 'remote_loading_error':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Error', null, { error: data.error || 'Loading failed' });
                    remoteProgress.className = 'progress-status error';
                    break;
                case 'unified_complete':
                    updateProgressStatus('local', 'Complete', data.localCount, null);
                    updateProgressStatus('remote', 'Complete', data.remoteCount, null);
                    localProgress.className = 'progress-status ready';
                    remoteProgress.className = 'progress-status ready';
                    break;
                case 'error':
                    updateProgressStatus('local', 'Error', data.localCount, { error: data.error });
                    updateProgressStatus('remote', 'Error', data.remoteCount, { error: data.error });
                    localProgress.className = 'progress-status error';
                    remoteProgress.className = 'progress-status error';
                    break;
            }
        }
        
        // Log phase transition for debugging with timing
        const timestamp = new Date().toLocaleTimeString();
        console.log(`[${timestamp}] Progressive Loading: Phase ${phase} - ${phaseConfig.message}`, phaseConfig.stats);
        
        return phaseConfig;
    } else {
        console.warn(`Progressive Loading: Unknown phase ${phase}`);
        return null;
    }
}

// Helper function to load media from cache
function tryLoadFromCache() {
    if (localStorage.getItem('mediaCache')) {
        try {
            const cachedData = JSON.parse(localStorage.getItem('mediaCache'));
            if (cachedData && cachedData.media) {
                mediaData = cachedData.media;
                const cacheAge = Math.round((Date.now() - (cachedData.timestamp || 0)) / 60000);
                
                // Update media count display
                const mainSectionCount = document.getElementById('mainMediaSectionCount');
                if (mainSectionCount) {
                    mainSectionCount.textContent = mediaData.length;
                }
                
                // Show appropriate message based on cache age
                if (cacheAge < 60) {
                    showMessage(`Loaded ${mediaData.length} items from cache (${cacheAge} minutes old)`, 'warning');
                } else {
                    const cacheHours = Math.round(cacheAge / 60);
                    showMessage(`Loaded ${mediaData.length} items from cache (${cacheHours} hours old) - consider refreshing`, 'warning');
                }
                
                filterMedia();
                return true;
            }
        } catch (cacheError) {
            console.error('Error loading from cache:', cacheError);
            showMessage('Failed to load cached data', 'error');
        }
    }
    return false;
}

// Global variable to hold current active view (e.g., 'movies', 'tv', 'all')
let currentViewFilter = 'movies'; // Default to 'movies'

// Remove the current `createMediaSection` function entirely, or rename it
// if you want to keep parts of its functionality, but it won't be creating
// an *inner* grid container anymore.

function renderMediaGrid() {
    console.log('Rendering media grid...');
    const mediaGrid = document.getElementById('mediaGrid');
    mediaGrid.innerHTML = ''; // Clear previous content

    // Get the actual filter being applied from the dropdown
    const activeFilterValue = document.getElementById('filterSelect').value;

    console.log('renderMediaGrid: filteredData length:', filteredData.length);
    console.log('renderMediaGrid: Current active filter:', activeFilterValue);

    // Update the section header based on the filter
    let sectionTitle = 'Media Library';
    if (activeFilterValue === 'movies') {
        sectionTitle = 'Movies';
    } else if (activeFilterValue === 'tv') {
        sectionTitle = 'TV Shows';
    } else if (activeFilterValue === 'local') {
        sectionTitle = 'Local Media';
    } else if (activeFilterValue === 'remote') {
        sectionTitle = 'Remote Media';
    } else if (activeFilterValue === 'both') {
        sectionTitle = 'Local & Remote Media';
    }

    // Update the section header element directly (you'll need to add this to your HTML)
    // We need a place for the title and count outside the main grid
    let mainSectionHeader = document.getElementById('mainMediaSectionHeader');
    let mainSectionTitle = document.getElementById('mainMediaSectionTitle');
    let mainSectionCount = document.getElementById('mainMediaSectionCount');

    if (!mainSectionHeader) {
        // If it doesn't exist, create it dynamically (or better, add it to your HTML)
        mainSectionHeader = document.createElement('div');
        mainSectionHeader.id = 'mainMediaSectionHeader';
        mainSectionHeader.className = 'section-header'; // Use your existing header style
        
        mainSectionTitle = document.createElement('h2');
        mainSectionTitle.id = 'mainMediaSectionTitle';
        mainSectionTitle.className = 'section-title';

        mainSectionCount = document.createElement('span');
        mainSectionCount.id = 'mainMediaSectionCount';
        mainSectionCount.className = 'section-count';

        mainSectionHeader.appendChild(mainSectionTitle);
        mainSectionHeader.appendChild(mainSectionCount);

        // Insert the header before the mediaGrid if it's the first render
        const container = mediaGrid.parentElement; // Assuming mediaGrid is inside a container like `block content`
        container.insertBefore(mainSectionHeader, mediaGrid);

    }

    mainSectionTitle.textContent = sectionTitle;
    mainSectionCount.textContent = filteredData.length;

    // Now, iterate through filteredData and append cards DIRECTLY to mediaGrid
    if (filteredData.length > 0) {
        filteredData.forEach(media => {
            const mediaCard = createMediaCard(media);
            mediaGrid.appendChild(mediaCard);
        });
        document.getElementById('noMedia').style.display = 'none';
    } else {
        document.getElementById('noMedia').style.display = 'block';
    }
    
    console.log('Media grid rendering complete');
}

function createMediaSection(title, mediaItems) {
    console.log(`createMediaSection: Creating section "${title}" with ${mediaItems.length} items.`); 
    const section = document.createElement('div');
    section.className = 'media-section'; // This wraps the header and the cards

    const header = document.createElement('div');
    header.className = 'section-header';
    header.innerHTML = `
        <h2 class="section-title">${title}</h2>
        <span class="section-count">${mediaItems.length}</span>
    `;

    // Container for media cards
    const cardsContainer = document.createElement('div');
    cardsContainer.className = 'media-cards-container';

    mediaItems.forEach(media => {
        const mediaCard = createMediaCard(media);
        cardsContainer.appendChild(mediaCard); // Append cards to the new container
    });

    section.appendChild(header);
    section.appendChild(cardsContainer); // Append the cards container to the section

    return section;
}


function createMediaCard(media) {
    console.log('createMediaCard: Processing media item:', media.title, 'ID:', media.id, 'Type:', media.type); // ADD THIS
    console.log('  - has_local:', media.has_local, 'has_remote:', media.has_remote); // ADD THIS
    console.log('  - poster_url:', media.poster_url, 'thumbnail_url:', media.thumbnail_url); // ADD THIS

    const card = document.createElement('div');
    card.className = 'media-card';
    card.dataset.mediaId = media.id;

    const availabilityClass = {
        'local_only': 'availability-local',
        'remote_only': 'availability-remote',
        'both': 'availability-both'
    }[media.availability] || 'availability-unknown';

    const availabilityText = {
        'local_only': 'Local',
        'remote_only': 'Remote',
        'both': 'Both'
    }[media.availability] || 'Unknown';

    const typeIcon = getMediaIcon(media.type);

    const posterUrl = media.poster_url || media.thumbnail_url;
    const hasImage = posterUrl && posterUrl.trim().length > 0;

    card.innerHTML = `
        <div class="media-poster" onclick="showActionOverlay(${JSON.stringify(media).replace(/"/g, '&quot;')})">
            ${hasImage ?
                `<img src="${posterUrl}" alt="${media.title}" class="poster-image" loading="lazy"
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">` : ''
            }
            <div class="poster-placeholder" ${hasImage ? 'style="display: none;"' : ''}>
                <div class="placeholder-icon">${typeIcon}</div>
                <div class="placeholder-title">${media.title}</div>
            </div>
            <div class="media-info">
                <div class="media-title">${media.title}</div>
                <div class="media-meta">
                    <span class="availability-badge ${availabilityClass}">${availabilityText}</span>
                    ${media.year ? `<span class="meta-year">${media.year}</span>` : ''}
                    ${media.duration ? `<span class="meta-duration">${formatDuration(media.duration)}</span>` : ''}
                </div>
            </div>
        </div>
    `;

    // Add touch feedback
    card.addEventListener('touchstart', () => {
        card.style.transform = 'translateY(-2px) scale(1.01)';
    });

    card.addEventListener('touchend', () => {
        setTimeout(() => {
            card.style.transform = '';
        }, 100);
    });

    return card;
}

function createPosterContent(media) {
    if (media.thumbnail_url || media.poster_url) {
        const posterUrl = media.poster_url || media.thumbnail_url;
        return `
            <img src="${posterUrl}" 
                 alt="${media.title}" 
                 loading="lazy"
                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
            <div class="poster-placeholder" style="display: none;">
                <div class="placeholder-icon">${getMediaIcon(media.type)}</div>
                <div class="placeholder-title">${media.title}</div>
            </div>
        `;
    } else {
        return `
            <div class="poster-placeholder">
                <div class="placeholder-icon">${getMediaIcon(media.type)}</div>
                <div class="placeholder-title">${media.title}</div>
            </div>
        `;
    }
}

function createActionButtons(media) {
    let buttons = [];
    
    // Local playback buttons
    if (media.has_local) {
        buttons.push(`<button class="btn btn-small btn-play" onclick="playLocal('${media.id}')"><span class="btn-icon">‚ñ∂Ô∏è</span>Play</button>`);
        buttons.push(`<button class="btn btn-small btn-secondary" onclick="playLocal('${media.id}', true)"><span class="btn-icon">‚õ∂</span>Full</button>`);
    }
    
    // Remote streaming and download buttons
    if (media.has_remote) {
        buttons.push(`<button class="btn btn-small btn-stream" onclick="streamMedia('${media.id}')"><span class="btn-icon">üåê</span>Stream</button>`);
        
        // Only show download if not already local
        if (!media.has_local) {
            buttons.push(`<button class="btn btn-small btn-download" onclick="downloadMedia('${media.id}')"><span class="btn-icon">‚¨áÔ∏è</span>Download</button>`);
        }
    }
    
    return buttons.join('');
}

function getMediaIcon(mediaType) {
    switch (mediaType) {
        case 'MOVIE':
            return 'üé¨';
        case 'TV_SHOW':
        case 'EPISODE':
            return 'üì∫';
        default:
            return 'üé≠';
    }
}

// Action Overlay Management
function showActionOverlay(media) {
    // Create overlay if it doesn't exist
    let overlay = document.getElementById('actionOverlay');
    if (!overlay) {
        overlay = createActionOverlay();
        document.body.appendChild(overlay);
    }
    
    // Populate overlay with media details
    populateActionOverlay(overlay, media);
    
    // Show overlay
    overlay.classList.add('active');
    document.body.style.overflow = 'hidden';
    
    // Focus management for accessibility
    const closeButton = overlay.querySelector('.overlay-close');
    if (closeButton) {
        closeButton.focus();
    }
}

function hideActionOverlay() {
    const overlay = document.getElementById('actionOverlay');
    if (overlay) {
        overlay.classList.remove('active');
        document.body.style.overflow = '';
    }
}

function createActionOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'actionOverlay';
    overlay.className = 'action-overlay';
    
    overlay.innerHTML = `

        <div class="action-overlay-content">
            <button class="overlay-close" onclick="hideActionOverlay()" aria-label="Close">
                √ó
            </button>
            <div class="overlay-media-info">
                <div class="overlay-poster">
                    <div class="poster-placeholder">
                        <div class="placeholder-icon">üé¨</div>
                    </div>
                </div>
                <div class="overlay-details">
                    <h2 class="overlay-title">Loading...</h2>
                    <div class="overlay-meta"></div>
                    <div class="overlay-description"></div>
                </div>
            </div>
            <div class="overlay-actions"></div>
            <div class="overlay-stats"></div>
        </div>
    `;
    
    // Close on backdrop click
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            hideActionOverlay();
        }
    });
    
    // Close on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay.classList.contains('active')) {
            hideActionOverlay();
        }
    });
    
    return overlay;
}

function populateActionOverlay(overlay, media) {
    const posterContainer = overlay.querySelector('.overlay-poster');
    const title = overlay.querySelector('.overlay-title');
    const meta = overlay.querySelector('.overlay-meta');
    const description = overlay.querySelector('.overlay-description');
    const actions = overlay.querySelector('.overlay-actions');
    const stats = overlay.querySelector('.overlay-stats');
    
    // Update poster
    posterContainer.innerHTML = createPosterContent(media);
    
    // Update title
    title.textContent = media.title;
    
    // Update meta information
    const metaItems = [];
    if (media.type) metaItems.push(media.type);
    if (media.year) metaItems.push(media.year);
    if (media.duration) metaItems.push(formatDuration(media.duration));
    
    const availabilityClass = {
        'local_only': 'availability-local',
        'remote_only': 'availability-remote',
        'both': 'availability-both'
    }[media.availability] || 'availability-unknown';
    
    const availabilityText = {
        'local_only': 'Local',
        'remote_only': 'Remote',
        'both': 'Both'
    }[media.availability] || 'Unknown';
    
    meta.innerHTML = `
        ${metaItems.join(' ‚Ä¢ ')}
        <span class="availability-badge ${availabilityClass}">${availabilityText}</span>
    `;
    
    // Update description
    description.textContent = media.description || media.overview || 'No description available.';
    
    // Update action buttons
    actions.innerHTML = createOverlayActionButtons(media);
    
    // Update stats
    stats.innerHTML = createMediaStats(media);
}

function createOverlayActionButtons(media) {
    const buttons = [];
    const connectivity = getConnectivitySummary();
    
    // Local playback buttons (always available if media has local files)
    if (media.has_local) {
        buttons.push(`
            <button class="overlay-action-btn btn-play-overlay" onclick="playLocal('${media.id}'); hideActionOverlay();">
                <span class="btn-icon">‚ñ∂Ô∏è</span>
                <span class="btn-text">Play Locally</span>
            </button>
        `);
        
        buttons.push(`
            <button class="overlay-action-btn" onclick="playLocal('${media.id}', true); hideActionOverlay();">
                <span class="btn-icon">‚õ∂</span>
                <span class="btn-text">Fullscreen</span>
            </button>
        `);
    }
    
    // Remote/streaming buttons (only if connectivity allows and media has remote access)
    if (media.has_remote) {
        if (connectivity.canStream) {
            buttons.push(`
                <button class="overlay-action-btn btn-stream-overlay" onclick="streamMedia('${media.id}'); hideActionOverlay();">
                    <span class="btn-icon">ÔøΩ<</span>
                    <span class="btn-text">Stream</span>
                </button>
            `);
        } else {
            buttons.push(`
                <button class="overlay-action-btn disabled" title="${connectivity.localOnly ? 'Offline mode - streaming unavailable' : 'Jellyfin server unavailable'}">
                    <span class="btn-icon">ÔøΩ<</span>
                    <span class="btn-text">Stream (Offline)</span>
                </button>
            `);
        }
        
        // Download button (only if not already local)
        if (!media.has_local) {
            if (connectivity.canDownload) {
                buttons.push(`
                    <button class="overlay-action-btn btn-download-overlay" onclick="downloadMedia('${media.id}'); hideActionOverlay();">
                        <span class="btn-icon">‚¨áÔ∏è</span>
                        <span class="btn-text">Download</span>
                    </button>
                `);
            } else {
                buttons.push(`
                    <button class="overlay-action-btn disabled" title="${connectivity.localOnly ? 'Offline mode - downloads unavailable' : 'Jellyfin server unavailable'}">
                        <span class="btn-icon">‚¨áÔ∏è</span>
                        <span class="btn-text">Download (Offline)</span>
                    </button>
                `);
            }
        }
    }
    
    // Add connectivity status indicator if offline
    if (connectivity.localOnly && !media.has_local) {
        buttons.push(`
            <div class="connectivity-notice">
                <span class="notice-icon">üì±</span>
                <span class="notice-text">Offline mode - Only local media available</span>
            </div>
        `);
    }
    
    return buttons.join('');
}

function createMediaStats(media) {
    const stats = [];
    
    // File size if available
    if (media.file_size) {
        stats.push(`
            <div class="stat-item">
                <div class="stat-label">File Size</div>
                <div class="stat-value">${formatFileSize(media.file_size)}</div>
            </div>
        `);
    }
    
    // Duration
    if (media.duration) {
        stats.push(`
            <div class="stat-item">
                <div class="stat-label">Duration</div>
                <div class="stat-value">${formatDuration(media.duration)}</div>
            </div>
        `);
    }
    
    // Quality if available
    if (media.quality || media.resolution) {
        stats.push(`
            <div class="stat-item">
                <div class="stat-label">Quality</div>
                <div class="stat-value">${media.quality || media.resolution}</div>
            </div>
        `);
    }
    
    // Availability
    stats.push(`
        <div class="stat-item">
            <div class="stat-label">Availability</div>
            <div class="stat-value">${media.has_local && media.has_remote ? 'Local + Remote' : media.has_local ? 'Local Only' : 'Remote Only'}</div>
        </div>
    `);
    
    return stats.join('');
}

// Overlay action handlers
async function playLocalFromOverlay(mediaId, fullscreen = false) {
    hideActionOverlay();
    await playLocal(mediaId, fullscreen);
}

async function streamMediaFromOverlay(mediaId) {
    hideActionOverlay();
    await streamMedia(mediaId);
}

async function downloadMediaFromOverlay(mediaId) {
    hideActionOverlay();
    await downloadMedia(mediaId);
}

function filterMedia() {
    const searchTerm = document.getElementById('searchBox').value.toLowerCase();
    const filterValue = document.getElementById('filterSelect').value;

    console.log('filterMedia: Applying search:', searchTerm, 'and filter:', filterValue);

    // Handle TV shows separately
    if (filterValue === 'tv') {
        console.log('TV filter selected, loading TV shows...');
        loadAndDisplayTVShows(searchTerm);
        return;
    }

    // Reset TV show view if switching away from TV
    if (currentTVShowView !== 'shows') {
        currentTVShowView = 'shows';
        currentShowData = null;
        currentSeasonData = null;
    }

    filteredData = mediaData.filter(media => {
        // Search filter
        const matchesSearch = !searchTerm ||
            media.title.toLowerCase().includes(searchTerm) ||
            (media.metadata && Object.values(media.metadata).some(value =>
                String(value).toLowerCase().includes(searchTerm)
            ));

        // Category filter
        let matchesFilter = true;
        switch (filterValue) {
            case 'local':
                matchesFilter = media.has_local;
                break;
            case 'remote':
                matchesFilter = media.has_remote && !media.has_local;
                break;
            case 'both':
                matchesFilter = media.has_local && media.has_remote;
                break;
            case 'movies':
                // Use lowercase 'movie' based on your console output
                matchesFilter = media.type === 'movie';
                break;
            case 'all': // 'all' filter doesn't restrict by type/availability
                matchesFilter = true;
                break;
            // No default needed as matchesFilter starts as true
        }

        const result = matchesSearch && matchesFilter;
        return result;
    });

    renderMediaGrid(); // Re-render the grid with the filtered data
}

// Global variable to store TV shows data
let tvShowsData = [];

async function loadAndDisplayTVShows(searchTerm = '') {
    console.log('Loading TV shows with search term:', searchTerm);

    try {
        // Ensure we're in the correct view state
        currentTVShowView = 'shows';
        currentShowData = null;
        currentSeasonData = null;

        // Show loading state
        updateStatusIndicator('Loading TV shows...', 'loading');

        // Fetch TV shows data
        console.log('Fetching TV shows from API...');
        const response = await fetch('/api/tv-shows?mode=unified');
        console.log('API response status:', response.status);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        tvShowsData = data.tv_shows || [];
        window.tvShowsData = tvShowsData; // Make available globally

        console.log(`Loaded ${tvShowsData.length} TV shows from API`);
        console.log('First TV show:', tvShowsData[0]);

        // Apply search filter if provided
        let filteredTVShows = tvShowsData;
        if (searchTerm) {
            console.log('Applying search filter:', searchTerm);
            filteredTVShows = tvShowsData.filter(show =>
                show.title.toLowerCase().includes(searchTerm) ||
                (show.metadata && Object.values(show.metadata).some(value =>
                    String(value).toLowerCase().includes(searchTerm)
                ))
            );
            console.log(`Filtered to ${filteredTVShows.length} shows`);
        }

        // Render TV shows grid
        console.log('Calling renderTVShowsGrid...');
        renderTVShowsGrid(filteredTVShows);

        updateStatusIndicator(`${filteredTVShows.length} TV shows loaded`, 'connected');

    } catch (error) {
        console.error('Error loading TV shows:', error);
        updateStatusIndicator('Failed to load TV shows', 'error');
        showMessage('Failed to load TV shows: ' + error.message, 'error');

        // Show empty state and ensure grid layout
        const mediaGrid = document.getElementById('mediaGrid');
        mediaGrid.style.display = ''; // Reset to grid
        mediaGrid.style.gridTemplateColumns = ''; // Reset grid columns
        mediaGrid.innerHTML = '<div class="no-episodes">Failed to load TV shows</div>';
    }
}

function renderTVShowsGrid(tvShows = null) {
    console.log('Rendering TV shows grid');

    const shows = tvShows || tvShowsData;
    const mediaGrid = document.getElementById('mediaGrid');

    // IMPORTANT: Always ensure grid layout is restored for TV shows view
    mediaGrid.style.display = ''; // Reset to default (should be grid)
    mediaGrid.style.gridTemplateColumns = ''; // Reset to default grid columns
    mediaGrid.className = 'media-grid'; // Ensure proper CSS class

    mediaGrid.innerHTML = '';

    console.log('TV shows to render:', shows.length);
    console.log('createTVShowCard function available:', typeof createTVShowCard);

    // Update section header
    const headerElement = document.getElementById('mainMediaSectionTitle');
    if (headerElement) {
        headerElement.textContent = 'TV Shows';
    }

    const countElement = document.getElementById('mainMediaSectionCount');
    if (countElement) {
        countElement.textContent = shows.length;
    }

    if (shows.length === 0) {
        mediaGrid.innerHTML = '<div class="no-episodes">No TV shows found</div>';
        return;
    }

    // Check if createTVShowCard function is available
    if (typeof createTVShowCard !== 'function') {
        console.error('createTVShowCard function not available!');
        mediaGrid.innerHTML = '<div class="no-episodes">TV show components not loaded</div>';
        return;
    }

    // Create TV show cards
    shows.forEach((tvShow, index) => {
        console.log(`Creating card for show ${index + 1}: ${tvShow.title}`);
        try {
            const showCard = createTVShowCard(tvShow);
            mediaGrid.appendChild(showCard);
        } catch (error) {
            console.error(`Error creating card for show ${tvShow.title}:`, error);
        }
    });

    document.getElementById('noMedia').style.display = 'none';
    console.log('TV shows grid rendering complete');
}

async function playLocal(mediaId, fullscreen = false) {
    try {
        const response = await fetch(`/api/play/local/${mediaId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ fullscreen })
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
            showMessage(`Started ${fullscreen ? 'fullscreen ' : ''}playback`, 'success');
        } else {
            showMessage(data.error || 'Failed to start playback', 'error');
        }
    } catch (error) {
        console.error('Error starting playback:', error);
        showMessage('Failed to start playback', 'error');
    }
}

async function streamMedia(mediaId, fullscreen = false) {
    // Check connectivity before attempting stream
    if (!canAccessRemoteMedia()) {
        if (isOfflineMode()) {
            showMessage('Cannot stream in offline mode. Try local playback instead.', 'warning');
        } else {
            showMessage('Cannot stream. Jellyfin server not available.', 'warning');
        }
        return;
    }
    
    try {
        const response = await fetch(`/api/play/stream/${mediaId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ fullscreen })
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
            showMessage('Started streaming', 'success');
        } else {
            showMessage(data.error || 'Failed to start streaming', 'error');
        }
    } catch (error) {
        console.error('Error starting stream:', error);
        
        // Check if error is due to connectivity
        if (!connectivityStatus.internet) {
            showMessage('Streaming failed: No internet connection', 'error');
        } else {
            showMessage('Failed to start streaming', 'error');
        }
    }
}

// Download Progress Management
let activeDownloads = new Map();
let downloadEventSource = null;
let downloadQueue = null;

async function downloadMedia(mediaId) {
    // Check connectivity before attempting download
    if (!canAccessRemoteMedia()) {
        if (isOfflineMode()) {
            showMessage('Cannot download in offline mode. Internet connection required.', 'warning');
        } else {
            showMessage('Cannot download. Jellyfin server not available.', 'warning');
        }
        return;
    }
    
    try {
        // First, get available media directories
        const dirResponse = await fetch('/api/media/directories');
        const dirData = await dirResponse.json();
        
        if (!dirResponse.ok) {
            showMessage('Failed to get media directories', 'error');
            return;
        }
        
        // Show directory selection dialog
        const selectedDirectory = await showDirectorySelectionDialog(dirData.directories, dirData.default_download_dir);
        
        if (!selectedDirectory) {
            // User cancelled the dialog
            return;
        }
        
        // Prepare download request data
        const downloadData = {};
        
        // If user selected a directory other than downloads, set it as final destination
        if (selectedDirectory !== dirData.default_download_dir) {
            downloadData.final_destination = selectedDirectory;
        }
        
        const response = await fetch(`/api/download/${mediaId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(downloadData)
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
            const destinationName = selectedDirectory === dirData.default_download_dir ? 
                'downloads' : selectedDirectory.split('/').pop();
            showMessage(`Download started to ${destinationName}`, 'success');
            
            // Start tracking this download
            const taskId = data.task_id || mediaId;
            startDownloadTracking(mediaId, taskId);
            
            // Initialize download progress system if not already done
            if (!downloadEventSource) {
                initializeDownloadProgress();
            }
            
        } else {
            showMessage(data.error || 'Failed to start download', 'error');
        }
    } catch (error) {
        console.error('Error starting download:', error);
        
        // Check if error is due to connectivity
        if (!connectivityStatus.internet) {
            showMessage('Download failed: No internet connection', 'error');
        } else {
            showMessage('Failed to start download', 'error');
        }
    }
}

function showDirectorySelectionDialog(directories, defaultDownloadDir) {
    return new Promise((resolve) => {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'modal-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        `;
        
        // Create modal dialog
        const dialog = document.createElement('div');
        dialog.className = 'directory-selection-dialog';
        dialog.style.cssText = `
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        `;
        
        // Create dialog content
        dialog.innerHTML = `
            <h3 style="color: #fff; margin-bottom: 1.5rem; text-align: center;">
                Select Download Destination
            </h3>
            <p style="color: #ccc; margin-bottom: 1.5rem; text-align: center;">
                Choose where to save the downloaded media file:
            </p>
            <div class="directory-options" style="margin-bottom: 2rem;">
                ${directories.map(dir => `
                    <div class="directory-option" style="
                        padding: 1rem;
                        margin-bottom: 0.5rem;
                        background-color: #3d3d3d;
                        border-radius: 6px;
                        cursor: pointer;
                        transition: background-color 0.2s ease;
                        border: 2px solid transparent;
                    " data-path="${dir.path}">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="color: #fff; font-weight: 600; margin-bottom: 0.25rem;">
                                    ${dir.name}
                                </div>
                                <div style="color: #aaa; font-size: 0.9rem;">
                                    ${dir.path}
                                </div>
                            </div>
                            <div style="color: ${dir.exists ? '#4CAF50' : '#f44336'}; font-size: 0.8rem;">
                                ${dir.exists ? '‚úì Available' : '‚ö† Not Found'}
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
            <div style="display: flex; gap: 1rem; justify-content: center;">
                <button id="cancelDownload" style="
                    padding: 0.75rem 1.5rem;
                    background-color: #666;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 1rem;
                ">Cancel</button>
                <button id="confirmDownload" style="
                    padding: 0.75rem 1.5rem;
                    background-color: #4CAF50;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 1rem;
                    opacity: 0.5;
                " disabled>Download</button>
            </div>
        `;
        
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);
        
        let selectedPath = null;
        
        // Add click handlers for directory options
        const options = dialog.querySelectorAll('.directory-option');
        const confirmBtn = dialog.querySelector('#confirmDownload');
        
        options.forEach(option => {
            option.addEventListener('click', () => {
                // Remove selection from all options
                options.forEach(opt => {
                    opt.style.borderColor = 'transparent';
                    opt.style.backgroundColor = '#3d3d3d';
                });
                
                // Select this option
                option.style.borderColor = '#4CAF50';
                option.style.backgroundColor = '#2d4d2d';
                
                selectedPath = option.dataset.path;
                confirmBtn.disabled = false;
                confirmBtn.style.opacity = '1';
            });
            
            // Add hover effects
            option.addEventListener('mouseenter', () => {
                if (selectedPath !== option.dataset.path) {
                    option.style.backgroundColor = '#4d4d4d';
                }
            });
            
            option.addEventListener('mouseleave', () => {
                if (selectedPath !== option.dataset.path) {
                    option.style.backgroundColor = '#3d3d3d';
                }
            });
        });
        
        // Add button handlers
        dialog.querySelector('#cancelDownload').addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve(null);
        });
        
        dialog.querySelector('#confirmDownload').addEventListener('click', () => {
            document.body.removeChild(overlay);
            resolve(selectedPath);
        });
        
        // Close on overlay click
        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
                document.body.removeChild(overlay);
                resolve(null);
            }
        });
        
        // Close on Escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(overlay);
                document.removeEventListener('keydown', handleEscape);
                resolve(null);
            }
        };
        document.addEventListener('keydown', handleEscape);
    });
}

function initializeDownloadProgress() {
    // Create download queue UI
    createDownloadQueue();
    
    // Initialize Server-Sent Events for real-time progress
    downloadEventSource = new EventSource('/api/download/progress');
    
    downloadEventSource.onmessage = function(event) {
        try {
            const eventData = JSON.parse(event.data);
            
            // Handle different event types
            if (eventData.type === 'progress') {
                updateDownloadProgress(eventData);
            } else if (eventData.type === 'connected') {
                console.log('Download progress stream connected');
            } else if (eventData.type === 'error') {
                console.error('Download progress stream error:', eventData.message);
            }
            // Ignore heartbeat events
            
        } catch (error) {
            console.error('Error parsing download progress data:', error);
        }
    };
    
    downloadEventSource.onerror = function(error) {
        console.error('Download progress EventSource error:', error);
        // Attempt to reconnect after a delay
        setTimeout(() => {
            if (downloadEventSource.readyState === EventSource.CLOSED) {
                initializeDownloadProgress();
            }
        }, 5000);
    };
}

function startDownloadTracking(mediaId, taskId) {
    // Find the media item to get its details
    const media = mediaData.find(m => m.id === mediaId);
    if (!media) return;
    
    // Add to active downloads
    activeDownloads.set(taskId, {
        mediaId: mediaId,
        media: media,
        progress: 0,
        status: 'starting',
        startTime: Date.now()
    });
    
    // Show progress overlay on the poster
    showDownloadProgressOnPoster(mediaId, taskId);
    
    // Update download queue
    updateDownloadQueue();
}

function showDownloadProgressOnPoster(mediaId, taskId) {
    const mediaCard = document.querySelector(`[data-media-id="${mediaId}"]`);
    if (!mediaCard) return;
    
    const poster = mediaCard.querySelector('.media-poster');
    if (!poster) return;
    
    // Create progress overlay
    const progressOverlay = document.createElement('div');
    progressOverlay.className = 'download-progress';
    progressOverlay.dataset.taskId = taskId;
    
    const media = activeDownloads.get(taskId)?.media;
    
    progressOverlay.innerHTML = `
        <div class="progress-container">
            <div class="progress-text">0%</div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: 0%"></div>
            </div>
        </div>
        <div class="progress-details">
            Downloading ${media?.title || 'media'}...
        </div>
        <button class="progress-cancel" onclick="cancelDownload('${taskId}')">
            Cancel
        </button>
    `;
    
    poster.appendChild(progressOverlay);
    
    // Show the overlay
    setTimeout(() => {
        progressOverlay.classList.add('active');
    }, 100);
}

function updateDownloadProgress(progressData) {
    const { task_id, progress, status, speed, eta, error } = progressData;
    
    // Update active downloads map
    if (activeDownloads.has(task_id)) {
        const download = activeDownloads.get(task_id);
        download.progress = progress || 0;
        download.status = status || 'downloading';
        download.speed = speed;
        download.eta = eta;
        download.error = error;
    }
    
    // Update poster progress overlay
    updatePosterProgress(task_id, progressData);
    
    // Update download queue
    updateDownloadQueue();
    
    // Handle completion or error
    if (status === 'completed') {
        handleDownloadComplete(task_id);
    } else if (status === 'failed' || status === 'cancelled') {
        handleDownloadError(task_id, error);
    }
}

function updatePosterProgress(taskId, progressData) {
    const progressOverlay = document.querySelector(`[data-task-id="${taskId}"]`);
    if (!progressOverlay) return;
    
    const { progress = 0, speed, eta } = progressData;
    
    // Update progress bar
    const progressFill = progressOverlay.querySelector('.progress-fill');
    const progressText = progressOverlay.querySelector('.progress-text');
    const progressDetails = progressOverlay.querySelector('.progress-details');
    
    if (progressFill) {
        progressFill.style.width = `${progress}%`;
    }
    
    if (progressText) {
        progressText.textContent = `${Math.round(progress)}%`;
    }
    
    if (progressDetails) {
        let details = `Downloading...`;
        if (speed) {
            details += ` (${formatSpeed(speed)})`;
        }
        if (eta) {
            details += ` ‚Ä¢ ETA: ${formatETA(eta)}`;
        }
        progressDetails.textContent = details;
    }
}

function handleDownloadComplete(taskId) {
    const download = activeDownloads.get(taskId);
    if (!download) return;
    
    // Show completion message
    showMessage(`Download completed: ${download.media.title}`, 'success');
    
    // Remove progress overlay with animation
    const progressOverlay = document.querySelector(`[data-task-id="${taskId}"]`);
    if (progressOverlay) {
        progressOverlay.classList.remove('active');
        setTimeout(() => {
            progressOverlay.remove();
        }, 300);
    }
    
    // Remove from active downloads
    activeDownloads.delete(taskId);
    
    // Update download queue
    updateDownloadQueue();
    
    // Refresh media library to show updated availability
    setTimeout(() => {
        loadMediaLibrary(true);
    }, 1000);
}

function handleDownloadError(taskId, error) {
    const download = activeDownloads.get(taskId);
    if (!download) return;
    
    // Show error message
    showMessage(`Download failed: ${download.media.title}${error ? ` - ${error}` : ''}`, 'error');
    
    // Remove progress overlay
    const progressOverlay = document.querySelector(`[data-task-id="${taskId}"]`);
    if (progressOverlay) {
        progressOverlay.classList.remove('active');
        setTimeout(() => {
            progressOverlay.remove();
        }, 300);
    }
    
    // Remove from active downloads
    activeDownloads.delete(taskId);
    
    // Update download queue
    updateDownloadQueue();
}

async function cancelDownload(taskId) {
    try {
        const response = await fetch(`/api/download/cancel/${taskId}`, {
            method: 'POST'
        });
        
        if (response.ok) {
            showMessage('Download cancelled', 'info');
        }
    } catch (error) {
        console.error('Error cancelling download:', error);
        showMessage('Failed to cancel download', 'error');
    }
}

function createDownloadQueue() {
    if (downloadQueue) return; // Already created
    
    downloadQueue = document.createElement('div');
    downloadQueue.className = 'download-queue';
    downloadQueue.id = 'downloadQueue';
    
    downloadQueue.innerHTML = `
        <div class="queue-header">
            <div class="queue-title">‚¨áÔ∏è Downloads</div>
            <button class="queue-close" onclick="hideDownloadQueue()">√ó</button>
        </div>
        <div class="queue-items" id="queueItems">
            <!-- Download items will be populated here -->
        </div>
    `;
    
    document.body.appendChild(downloadQueue);
}

function showDownloadQueue() {
    if (!downloadQueue) createDownloadQueue();
    downloadQueue.classList.add('active');
}

function hideDownloadQueue() {
    if (downloadQueue) {
        downloadQueue.classList.remove('active');
    }
}

function toggleDownloadQueue() {
    if (!downloadQueue) {
        createDownloadQueue();
    }
    
    if (downloadQueue.classList.contains('active')) {
        hideDownloadQueue();
    } else {
        showDownloadQueue();
    }
}

function updateDownloadQueue() {
    if (!downloadQueue) return;
    
    const queueItems = downloadQueue.querySelector('#queueItems');
    if (!queueItems) return;
    
    // Update download button visibility and count
    const downloadBtn = document.getElementById('downloadQueueBtn');
    const downloadCountEl = document.getElementById('downloadCount');
    
    if (activeDownloads.size === 0) {
        if (downloadBtn) downloadBtn.style.display = 'none';
        hideDownloadQueue();
        return;
    } else {
        if (downloadBtn) downloadBtn.style.display = 'inline-flex';
        if (downloadCountEl) downloadCountEl.textContent = activeDownloads.size;
    }
    
    // Clear existing items
    queueItems.innerHTML = '';
    
    // Add each active download
    activeDownloads.forEach((download, taskId) => {
        const queueItem = document.createElement('div');
        queueItem.className = 'queue-item';
        
        const posterUrl = download.media.poster_url || '';
        const progress = Math.round(download.progress || 0);
        const status = getDownloadStatusText(download.status, download.progress);
        
        queueItem.innerHTML = `
            <div class="queue-poster">
                ${posterUrl ? 
                    `<img src="${posterUrl}" alt="${download.media.title}">` :
                    `<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-size: 1.5rem;">üé¨</div>`
                }
            </div>
            <div class="queue-info">
                <div class="queue-title-text">${download.media.title}</div>
                <div class="queue-progress">${progress}%</div>
                <div class="queue-status">${status}</div>
            </div>
        `;
        
        queueItems.appendChild(queueItem);
    });
}

function getDownloadStatusText(status, progress) {
    switch (status) {
        case 'starting':
            return 'Initializing...';
        case 'downloading':
            return `Downloading... ${Math.round(progress || 0)}%`;
        case 'completed':
            return 'Completed';
        case 'failed':
            return 'Failed';
        case 'cancelled':
            return 'Cancelled';
        default:
            return 'Processing...';
    }
}

function formatSpeed(bytesPerSecond) {
    if (!bytesPerSecond) return '';
    
    const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
    let size = bytesPerSecond;
    let unitIndex = 0;
    
    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }
    
    return `${size.toFixed(1)} ${units[unitIndex]}`;
}

function formatETA(seconds) {
    if (!seconds || seconds <= 0) return '';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hours > 0) {
        return `${hours}h ${minutes}m`;
    } else if (minutes > 0) {
        return `${minutes}m ${secs}s`;
    } else {
        return `${secs}s`;
    }
}

// Connectivity Monitoring Functions
async function initializeConnectivityMonitoring() {
    console.log('Initializing enhanced connectivity monitoring with StatusManager');
    
    try {
        // Initialize StatusManager for non-blocking status checks
        await initializeStatusManager();
        
        // Set up browser event listeners for online/offline detection
        window.addEventListener('online', handleOnlineEvent);
        window.addEventListener('offline', handleOfflineEvent);
        
        // Listen for visibility change to refresh status when tab becomes active
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && statusManager) {
                console.log('Tab became active - refreshing status');
                // Clear cache and force a fresh check when tab becomes active
                statusManager.clearCache();
                statusManager.checkInternetConnectivity().then(() => {
                    if (statusManager.getStatus('internet').connected) {
                        statusManager.checkJellyfinConnectivity();
                    }
                });
            }
        });
        
        console.log('Connectivity monitoring initialized successfully');
        
    } catch (error) {
        console.error('Failed to initialize connectivity monitoring:', error);
        
        // Fallback to legacy status checking if StatusManager fails
        console.log('Falling back to legacy status checking');
        await fallbackToLegacyStatusChecking();
    }
}

// Fallback function for legacy status checking if StatusManager fails
async function fallbackToLegacyStatusChecking() {
    console.log('Using legacy status checking as fallback');
    
    // Check initial connectivity status
    await checkConnectivityStatus();
    
    // Initial system status check
    await checkSystemStatus(true);
    
    // Set up periodic checks
    statusCheckInterval = setInterval(() => {
        const fullCheck = (Math.floor(Date.now() / 1000) % 600) < 10;
        checkSystemStatus(fullCheck);
    }, 120000);
    
    connectivityCheckInterval = setInterval(checkConnectivityStatus, 30000);
}

async function checkConnectivityStatus() {
    // Show loading state for internet check
    setServiceLoadingState('internet', true, 'Internet: Checking...');
    
    try {
        let isOnline = false;
        let internetDetails = {};
        
        // Use StatusManager if available
        if (statusManager) {
            console.log('Using StatusManager for connectivity check');
            const internetResult = await statusManager.checkInternetConnectivity();
            isOnline = internetResult.connected;
            internetDetails = { method: internetResult.method };
        } else {
            // Fallback to legacy connectivity check
            console.log('Using legacy connectivity check');
            isOnline = await checkInternetConnectivity();
        }
        
        connectivityStatus.internet = isOnline;
        connectivityStatus.lastCheck = new Date();
        
        // Update service status with real-time feedback
        updateServiceStatus('internet', isOnline, internetDetails);
        
        if (isOnline && connectivityStatus.offlineMode) {
            handleOnlineEvent();
        } else if (!isOnline && !connectivityStatus.offlineMode) {
            handleOfflineEvent();
        }
        
    } catch (error) {
        console.error('Error checking connectivity:', error);
        updateServiceStatus('internet', false);
        connectivityStatus.internet = false;
    }
}

async function checkInternetConnectivity() {
    const timeout = 5000; // 5 second timeout
    
    // Multiple connectivity check methods
    const checks = [
        // Check with a reliable external service (Google's DNS)
        fetch('https://dns.google/resolve?name=google.com', { 
            method: 'GET', 
            cache: 'no-cache',
            signal: AbortSignal.timeout(timeout)
        }),
        
        // Fallback to another external service
        fetch('https://httpbin.org/get?nocache=' + Date.now(), {
            method: 'GET',
            cache: 'no-cache',
            signal: AbortSignal.timeout(timeout)
        }),
        
        // Check with API endpoint - always skip Jellyfin check for connectivity tests
        fetch('/api/status?skip_jellyfin=true', {
            method: 'GET',
            cache: 'no-cache',
            signal: AbortSignal.timeout(timeout)
        }),
        
        // Check navigator.onLine as fallback
        Promise.resolve(navigator.onLine)
    ];
    
    try {
        // Try the first check (Google DNS)
        await checks[0];
        return true;
    } catch {
        try {
            // Try the second check (httpbin)
            await checks[1];
            return true;
        } catch {
            try {
                // Try the third check (local API)
                await checks[2];
                return true;
            } catch {
                // Fall back to navigator.onLine
                return navigator.onLine;
            }
        }
    }
}

async function checkSystemStatus(forceFullCheck = false) {
    console.log('checkSystemStatus called - internet:', connectivityStatus.internet, 'jellyfinConfirmed:', connectivityStatus.jellyfinConfirmed, 'forceFullCheck:', forceFullCheck);
    
    // If StatusManager is available, use it instead of legacy checking
    if (statusManager) {
        console.log('Using StatusManager for status check');
        try {
            // Force a fresh check if requested
            if (forceFullCheck) {
                statusManager.clearCache();
            }
            
            // Show loading states for all services being checked
            setServiceLoadingState('internet', true);
            setServiceLoadingState('jellyfin', true);
            setServiceLoadingState('vlc', true);
            
            // Check internet first
            const internetStatus = await statusManager.checkInternetConnectivity();
            updateServiceStatus('internet', internetStatus.connected, { method: internetStatus.method });
            
            // Check Jellyfin only if internet is available
            let jellyfinStatus = { connected: false };
            if (internetStatus.connected) {
                jellyfinStatus = await statusManager.checkJellyfinConnectivity();
                updateServiceStatus('jellyfin', jellyfinStatus.connected, { serverUrl: jellyfinStatus.serverUrl });
            } else {
                updateServiceStatus('jellyfin', false);
            }
            
            // Check other services
            const vlcStatus = await statusManager.checkVLCAvailability();
            updateServiceStatus('vlc', vlcStatus.available, { path: vlcStatus.path });
            
            // Update connectivityStatus for compatibility
            updateConnectivityStatusFromManager(statusManager.getStatus());
            
            // Update UI display
            updateSystemStatusDisplay(convertStatusManagerToLegacyFormat(statusManager.getStatus()));
            
            return;
            
        } catch (error) {
            console.error('StatusManager check failed, falling back to legacy:', error);
            // Continue with legacy checking below
        }
    }
    
    // Legacy status checking (fallback)
    // If we have internet and Jellyfin was previously confirmed, and we're not forcing a full check,
    // we can skip the Jellyfin check
    if (connectivityStatus.internet && connectivityStatus.jellyfinConfirmed && !forceFullCheck) {
        console.log('Skipping full Jellyfin status check - using cached status (internet available and Jellyfin previously confirmed)');
        
        // We still need to check VLC and other services
        try {
            console.log('Making lightweight status check (skip_jellyfin=true)');
            // Use a lightweight check that doesn't ping Jellyfin
            const response = await fetch('/api/status?skip_jellyfin=true', {
                method: 'GET',
                cache: 'no-cache',
                signal: AbortSignal.timeout(5000)
            });
            
            console.log('Lightweight status API response:', response.status, response.ok);
            
            if (response.ok) {
                const status = await response.json();
                console.log('Lightweight status API data:', status);
                
                // Always force the Jellyfin status to connected when we have a cached confirmation
                // This ensures we don't rely on the server's skipped_check flag which might not be working correctly
                status.services.jellyfin.connected = true;
                console.log('Forcing Jellyfin status to connected (cached)');
                
                // Update the UI with our modified status (Jellyfin always connected)
                updateSystemStatusDisplay(status);
            }
        } catch (error) {
            console.log('Lightweight status check failed, but keeping Jellyfin status as connected:', error);
            
            // Just update the UI to show Jellyfin is connected even if the request failed
            const jellyfinStatus = document.getElementById('jellyfinStatus');
            const jellyfinText = document.getElementById('jellyfinText');
            if (jellyfinStatus && jellyfinText) {
                jellyfinStatus.className = 'status-indicator status-online';
                jellyfinText.textContent = 'Jellyfin: Connected (Cached)';
                console.log('Updated Jellyfin status display to cached connected state');
            }
        }
        return;
    }
    
    // Otherwise, perform a full status check
    try {
        console.log('Performing full system status check including Jellyfin');
        console.log('Making request to /api/status');
        
        // Show loading states for services being checked
        setServiceLoadingState('jellyfin', true);
        setServiceLoadingState('vlc', true);
        
        const response = await fetch('/api/status', {
            method: 'GET',
            cache: 'no-cache',
            signal: AbortSignal.timeout(10000)
        });
        
        console.log('Status API response received:', response.status, response.ok);
        
        if (response.ok) {
            const status = await response.json();
            console.log('Status API response data:', status);
            
            // If Jellyfin is connected, remember this for future checks
            if (status.services && status.services.jellyfin && status.services.jellyfin.connected) {
                connectivityStatus.jellyfinConfirmed = true;
                console.log('Jellyfin connection confirmed - will use cached status for future checks');
                
                // Store in localStorage to persist across page reloads
                try {
                    localStorage.setItem('jellyfinConfirmed', 'true');
                    localStorage.setItem('jellyfinConfirmedTimestamp', Date.now().toString());
                    console.log('Stored jellyfinConfirmed in localStorage');
                } catch (e) {
                    console.warn('Failed to store jellyfinConfirmed in localStorage:', e);
                }
            } else {
                connectivityStatus.jellyfinConfirmed = false;
                console.log('Jellyfin not connected - clearing cached status');
                
                // Clear from localStorage
                try {
                    localStorage.removeItem('jellyfinConfirmed');
                    localStorage.removeItem('jellyfinConfirmedTimestamp');
                    console.log('Cleared jellyfinConfirmed from localStorage');
                } catch (e) {
                    console.warn('Failed to remove jellyfinConfirmed from localStorage:', e);
                }
            }
            
            console.log('Updating system status display');
            updateSystemStatusDisplay(status);
        } else {
            console.error('Status API returned non-OK response:', response.status, response.statusText);
            throw new Error(`Status check failed: ${response.status} ${response.statusText}`);
        }
        
    } catch (error) {
        console.error('Error checking system status:', error);
        
        // If we can't reach the status endpoint, assume services are down
        connectivityStatus.jellyfinConfirmed = false;
        console.log('Setting services as down due to error');
        updateSystemStatusDisplay({
            services: {
                jellyfin: { connected: false },
                vlc: { installed: false }
            },
            services_ready: false
        });
    }
}

function updateSystemStatusDisplay(status) {
    const timestamp = new Date().toLocaleTimeString();
    
    // Update Internet status with real-time feedback
    const internetStatus = document.getElementById('internetStatus');
    const internetText = document.getElementById('internetText');
    
    if (internetStatus && internetText) {
        const internetConnected = connectivityStatus.internet;
        if (internetConnected) {
            internetStatus.className = 'status-indicator status-online';
            internetText.textContent = 'Internet: Connected';
            internetText.title = `Connected - Last checked: ${timestamp}`;
        } else {
            internetStatus.className = 'status-indicator status-offline';
            internetText.textContent = 'Internet: Offline';
            internetText.title = `Offline - Last checked: ${timestamp}`;
        }
    }
    
    // Update Jellyfin status with enhanced feedback and loading states
    const jellyfinStatus = document.getElementById('jellyfinStatus');
    const jellyfinText = document.getElementById('jellyfinText');
    
    if (jellyfinStatus && jellyfinText) {
        if (status.services.jellyfin.connected) {
            jellyfinStatus.className = 'status-indicator status-online';
            const serverUrl = status.services.jellyfin.server_url;
            jellyfinText.textContent = serverUrl ? 
                `Jellyfin: Connected (${serverUrl})` : 
                'Jellyfin: Connected';
            jellyfinText.title = `Connected - Last updated: ${timestamp}`;
        } else {
            jellyfinStatus.className = 'status-indicator status-offline';
            jellyfinText.textContent = 'Jellyfin: Offline';
            jellyfinText.title = `Offline - Last checked: ${timestamp}`;
        }
    }
    
    // Update VLC status with enhanced feedback
    const vlcStatus = document.getElementById('vlcStatus');
    const vlcText = document.getElementById('vlcText');
    
    if (vlcStatus && vlcText) {
        if (status.services.vlc.installed) {
            vlcStatus.className = 'status-indicator status-online';
            const vlcPath = status.services.vlc.path;
            vlcText.textContent = vlcPath ? 
                `VLC: Available (${vlcPath})` : 
                'VLC: Available';
            vlcText.title = `Available - Last checked: ${timestamp}`;
        } else {
            vlcStatus.className = 'status-indicator status-offline';
            vlcText.textContent = 'VLC: Not Found';
            vlcText.title = `Not found - Last checked: ${timestamp}`;
        }
    }
    
    // Update Services status with enhanced feedback
    const servicesStatus = document.getElementById('servicesStatus');
    const servicesText = document.getElementById('servicesText');
    
    if (servicesStatus && servicesText) {
        if (status.services_ready) {
            servicesStatus.className = 'status-indicator status-online';
            servicesText.textContent = 'Services: Ready';
            servicesText.title = `All services operational - ${timestamp}`;
        } else {
            servicesStatus.className = 'status-indicator status-offline';
            servicesText.textContent = 'Services: Not Ready';
            
            // Provide more specific feedback about what's not ready
            const issues = [];
            if (!connectivityStatus.internet) issues.push('No Internet');
            if (!status.services.jellyfin.connected) issues.push('Jellyfin Offline');
            if (!status.services.vlc.installed) issues.push('VLC Missing');
            
            servicesText.title = issues.length > 0 ? 
                `Issues: ${issues.join(', ')} - ${timestamp}` : 
                `Services not ready - ${timestamp}`;
        }
    }
    
    // Update connectivity status object for compatibility
    connectivityStatus.jellyfin = status.services.jellyfin.connected;
    connectivityStatus.vlc = status.services.vlc.installed;   
    connectivityStatus.services = status.services_ready;
    
    // Update overall system status with enhanced visual feedback
    updateOverallSystemStatus();
    
    // Emit custom event for other components that might need to react
    window.dispatchEvent(new CustomEvent('systemStatusUpdated', {
        detail: { status, timestamp, connectivityStatus }
    }));
}

function updateOverallSystemStatus() {
    const systemStatus = document.getElementById('systemStatus');
    const { internet, jellyfin, vlc, services } = connectivityStatus;
    
    // Determine overall status
    if (!internet) {
        systemStatus.className = 'system-status offline';
    } else if (!jellyfin || !services) {
        systemStatus.className = 'system-status degraded';
    } else {
        systemStatus.className = 'system-status';
    }
}

// Ensure accurate status display within 10 seconds (requirement 2.4)
function ensureAccurateStatusDisplay() {
    console.log('Ensuring accurate status display within 10 seconds');
    
    // Check if any service is still in checking state and force final status
    const services = ['internet', 'jellyfin', 'vlc'];
    
    services.forEach(service => {
        const statusElement = document.getElementById(`${service}Status`);
        const textElement = document.getElementById(`${service}Text`);
        
        if (statusElement && statusElement.classList.contains('status-checking')) {
            console.log(`Service ${service} still checking after 10 seconds, forcing final status`);
            
            // Use current connectivity status or default to offline/unavailable
            let connected = false;
            let details = {};
            
            if (service === 'internet') {
                connected = connectivityStatus.internet;
            } else if (service === 'jellyfin') {
                connected = connectivityStatus.jellyfin;
            } else if (service === 'vlc') {
                connected = connectivityStatus.vlc;
            }
            
            updateServiceStatus(service, connected, details);
        }
    });
    
    // Emit event to indicate status display is now accurate
    window.dispatchEvent(new CustomEvent('statusDisplayAccurate', {
        detail: { 
            timestamp: Date.now(),
            connectivityStatus: { ...connectivityStatus }
        }
    }));
}

function handleOnlineEvent() {
    console.log('Device came online');
    connectivityStatus.offlineMode = false;
    
    // Reset Jellyfin confirmation status to force a fresh check when coming back online
    connectivityStatus.jellyfinConfirmed = false;
    
    // Hide offline mode indicator
    const offlineMode = document.getElementById('offlineMode');
    if (offlineMode) {
        offlineMode.style.display = 'none';
    }
    
    // Handle offline mode recovery in progressive loader
    if (window.progressiveLoader) {
        window.progressiveLoader.handleOfflineModeRecovery();
    }
    
    // Check all services immediately
    checkConnectivityStatus();
    checkSystemStatus(true); // Force a full check when coming back online
    
    // Show success message
    showMessage('Back online! Checking services...', 'success');
    
    // Refresh media library to get latest data
    setTimeout(() => {
        loadMediaLibrary(true);
    }, 2000);
}

function handleOfflineEvent() {
    console.log('Device went offline');
    connectivityStatus.offlineMode = true;
    
    // Show offline mode indicator
    const offlineMode = document.getElementById('offlineMode');
    if (offlineMode) {
        offlineMode.style.display = 'flex';
    }
    
    // Enable offline mode indicators in progressive loader
    if (window.progressiveLoader) {
        window.progressiveLoader.enableOfflineModeIndicators();
    }
    
    // Update system status
    updateOverallSystemStatus();
    
    // Show offline message
    showMessage('Offline mode activated. Only local media available.', 'warning');
    
    // Filter to show only local media
    const filterSelect = document.getElementById('filterSelect');
    if (filterSelect && filterSelect.value !== 'local') {
        filterSelect.value = 'local';
        filterMedia();
    }
}

function isOfflineMode() {
    return connectivityStatus.offlineMode || !connectivityStatus.internet;
}

function canAccessRemoteMedia() {
    return connectivityStatus.internet && connectivityStatus.jellyfin;
}

function getConnectivitySummary() {
    return {
        ...connectivityStatus,
        canDownload: canAccessRemoteMedia(),
        canStream: canAccessRemoteMedia(),
        canSync: canAccessRemoteMedia(),
        localOnly: isOfflineMode()
    };
}

async function refreshLibrary() {
    // Check connectivity before refresh
    if (isOfflineMode()) {
        showMessage('Offline mode: Refreshing local library only', 'warning');
    }
    
    console.log('Manual refresh triggered - clearing cached status and forcing full system status check');
    
    // Clear StatusManager cache if available
    if (statusManager) {
        statusManager.clearCache();
        // Force fresh status checks
        await statusManager.checkInternetConnectivity();
        if (statusManager.getStatus('internet').connected) {
            await statusManager.checkJellyfinConnectivity();
        }
    } else {
        // Legacy: Clear cached Jellyfin status to force a fresh check
        connectivityStatus.jellyfinConfirmed = false;
        // Force a full system status check (including Jellyfin) on manual refresh
        await checkSystemStatus(true);
    }
    
    // Clear progressive loader cache to force fresh data
    if (window.progressiveLoader) {
        window.progressiveLoader.clearCache();
    }
    
    await loadMediaLibrary(true);
}

async function syncLibraries() {
    // Check connectivity before attempting sync
    if (!canAccessRemoteMedia()) {
        if (isOfflineMode()) {
            showMessage('Cannot sync in offline mode. Internet connection required.', 'warning');
        } else {
            showMessage('Cannot sync. Jellyfin server not available.', 'warning');
        }
        return;
    }
    
    try {
        showMessage('Starting library sync...', 'info');
        
        const response = await fetch('/api/sync', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                mode: 'immediate'  // Request immediate synchronization
            })
        });
        
        const data = await response.json();
        
        if (response.ok && data.success) {
            showMessage('Library sync completed', 'success');
            await loadMediaLibrary(true);
        } else {
            showMessage(data.error || 'Failed to sync libraries', 'error');
        }
    } catch (error) {
        console.error('Error syncing libraries:', error);
        
        // Check if error is due to connectivity
        if (!connectivityStatus.internet) {
            showMessage('Sync failed: No internet connection', 'error');
        } else {
            showMessage('Failed to sync libraries', 'error');
        }
    }
}

// Background progress indicator functions
function showBackgroundProgress(show = true) {
    const container = document.getElementById('backgroundProgressContainer');
    if (container) {
        if (show) {
            container.style.display = 'block';
            setTimeout(() => container.classList.add('show'), 100);
        } else {
            container.classList.remove('show');
            setTimeout(() => container.style.display = 'none', 300);
        }
    }
}

function updateBackgroundProgress(percentage, message, details = null, timeEstimate = null) {
    const progressBar = document.getElementById('backgroundProgressBar');
    const progressText = document.getElementById('backgroundProgressText');
    const progressDetails = document.getElementById('backgroundProgressDetails');
    const progressTime = document.getElementById('backgroundProgressTime');

    if (progressBar) {
        progressBar.style.width = `${Math.max(0, Math.min(100, percentage))}%`;
    }

    if (progressText && message) {
        progressText.textContent = message;
    }

    if (progressDetails) {
        if (details) {
            progressDetails.textContent = details;
            progressDetails.style.display = 'block';
        } else {
            progressDetails.style.display = 'none';
        }
    }

    if (progressTime) {
        if (timeEstimate) {
            progressTime.textContent = timeEstimate;
            progressTime.style.display = 'block';
        } else {
            progressTime.style.display = 'none';
        }
    }
}

function hideBackgroundProgress() {
    showBackgroundProgress(false);
}

// Enhanced error handling for service unavailability
function handleServiceError(service, error) {
    console.log(`Handling ${service} service error:`, error);
    
    if (window.statusManager) {
        window.statusManager.displayServiceError(service, error);
    }
    
    // Update UI based on service type
    switch (service) {
        case 'internet':
            handleOfflineEvent();
            break;
        case 'jellyfin':
            showMessage('Remote media server unavailable - using local content only', 'warning');
            break;
        case 'localMedia':
            showMessage('Local media unavailable - check storage access', 'error');
            break;
    }
}

// Enhanced connectivity mode updates with user feedback
function updateConnectivityModeWithFeedback(mode) {
    updateConnectivityMode(mode);
    
    if (window.statusManager) {
        const modeInfo = window.statusManager.getConnectivityModeInfo();
        
        // Show connectivity status notification
        const notification = {
            type: 'connectivity_status',
            title: `Connection Status: ${mode.charAt(0).toUpperCase() + mode.slice(1)}`,
            message: modeInfo.description,
            icon: mode === 'online' ? 'üåê' : mode === 'degraded' ? '‚ö†Ô∏è' : 'üì±',
            severity: mode === 'online' ? 'success' : mode === 'degraded' ? 'warning' : 'info',
            autoHide: mode === 'online',
            duration: 3000
        };
        
        // Show capabilities and limitations
        if (modeInfo.capabilities.length > 0) {
            notification.suggestions = modeInfo.capabilities.map(cap => `‚úì ${cap}`);
        }
        
        if (modeInfo.limitations.length > 0) {
            notification.suggestions = (notification.suggestions || []).concat(
                modeInfo.limitations.map(limit => `‚úó ${limit}`)
            );
        }
        
        showConnectivityNotification(notification);
    }
}

// Show connectivity status notification
function showConnectivityNotification(notification) {
    // Create and show notification using the error notification system
    const element = document.createElement('div');
    element.className = `error-notification severity-${notification.severity}`;
    element.setAttribute('data-type', notification.type);
    
    element.innerHTML = `
        <div class="error-icon">${notification.icon}</div>
        <div class="error-content">
            <div class="error-title">${notification.title}</div>
            <div class="error-message">${notification.message}</div>
            ${notification.suggestions ? `
                <div class="error-suggestions">
                    <ul>
                        ${notification.suggestions.map(suggestion => `<li>${suggestion}</li>`).join('')}
                    </ul>
                </div>
            ` : ''}
        </div>
        <div class="error-actions">
            <button class="btn-dismiss" onclick="this.closest('.error-notification').dispatchEvent(new CustomEvent('dismiss'))">
                Dismiss
            </button>
        </div>
    `;

    // Add dismiss handler
    element.addEventListener('dismiss', () => {
        element.classList.add('dismissing');
        setTimeout(() => {
            if (element.parentNode) {
                element.parentNode.removeChild(element);
            }
        }, 300);
    });

    // Show notification
    let container = document.getElementById('errorNotificationContainer');
    if (!container) {
        container = document.createElement('div');
        container.id = 'errorNotificationContainer';
        container.className = 'error-notification-container';
        document.body.appendChild(container);
    }

    container.appendChild(element);
    setTimeout(() => element.classList.add('show'), 100);

    // Auto-hide if specified
    if (notification.autoHide && notification.duration) {
        setTimeout(() => {
            element.dispatchEvent(new CustomEvent('dismiss'));
        }, notification.duration);
    }
}
</script>

<!-- Mode Consistency Manager -->
<script src="{{ url_for('static', filename='js/mode-consistency-manager.js') }}"></script>

<!-- Progressive Media Loader -->
<script src="{{ url_for('static', filename='js/progressive-media-loader.js') }}"></script>

<!-- TV Show Components -->
<script src="{{ url_for('static', filename='js/tv-show-components.js') }}"></script>

<!-- Progressive Loading Test (for development) -->
<script src="{{ url_for('static', filename='js/progressive-loading-test.js') }}"></script>
{% endblock %}